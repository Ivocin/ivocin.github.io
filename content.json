{"pages":[{"title":"关于我","text":"","link":"/about/index.html"}],"posts":[{"title":"React Conf 2018 专题 —— React Today and Tomorrow Part I 视频中英双语字幕","text":"本文掘金地址：React Conf 2018 专题 —— React Today and Tomorrow Part I 视频中英双语字幕最近在 掘金翻译计划 校对了一篇 Dan Abramov 的关于 React Hooks 的文章，在 Sophie Alpert 和 Dan 在 React Conf 2018 上对 Hooks 的提案之后， Hooks 非常火。想到由于原视频在 Youtube 上的原因导致大部分小伙伴没法观看，而且官方没有提供英文字幕，YouTube 里面的英文字幕是机器自动生成的，错误比较多也没有断句，所以想把 React Conf 2018 的视频中英文字幕配好供大家一起学习。我看B站上已经搬运了 React Conf 2018 的全套视频，大家可以去围观。 2018年11月30日更新，小发已经把前两部分视频上传到 b 站上了，没广告特别好，视频地址：【React Conf 2018】React 的今天和明天中英文双字幕 视频地址：React Today And Tomorrow Part I —— 中英双语字幕 翻译字幕的难度远超过了我的预估，首先是听力方面，有些单词实在听不出来，第二个困难就是视频太长了，精校需要花费大量时间，所以决定逐步翻译，先把 Sophie 的演讲（10 分钟左右）翻译出来，光棍节在星巴克坐了一上午才校对翻译完毕。 简单介绍一下视频的内容，该视频是 React Conf 2018 的开场，首先是 React 的技术经理 Tom 的开场暖场，然后是 Sophie 和 Dan 的主题演讲： React Today and Tomorrow ，这里是视频的第一部分，Sophie 的演讲内容，视频的英文字幕进行了校对，并翻译了中文字幕。 另外如果看视频不方便的同学，可以移步到这篇文章：[译] React 的今天和明天（图文版） —— 第一部分，我把 Sophie 的keynote 截图并翻译整理好了，可以作为参考。 当然 Dan 的演讲才是重头戏，时间也比较长，还请有兴趣的小伙伴联系我，可以一起翻译和校对，这样效率会高些。我把译文放到了我的 Github 仓库上了，如果大家看到有中英文字幕的问题欢迎 pr。 2018 年 11 月 20 日更新， Dan 的 49 分钟演讲的中英文字幕快要完成了，感谢开源社区找到了小伙伴一起完成这个工作，我们这次的字幕质量很高，敬请期待。 传送门 最重要的 React 官方文档：Introducing Hooks [译] React 的今天和明天（图文版） —— 第一部分 [译] React 的今天和明天（图文版） —— 第二部分 前两部分视频地址（B 站）：【React Conf 2018】React 的今天和明天中英文双字幕 第一部分视频地址（爱奇艺）：React Today And Tomorrow Part I —— Sophie’s Keynote 中英双语字幕 第二部分视频地址（爱奇艺）：React Today And Tomorrow Part II —— Dan’s Keynote 中英双语字幕 Dan 对本次演讲的精炼文章（需要科学上网）：Making Sense of React Hooks 上面文章的译文：[译] 理解 React Hooks 一篇非常好的理解 React Hook 的文章：30 分钟精通 React Hooks","link":"/2018/11/12/React_today_and_tomorrow_video1/"},{"title":"React Conf 2018 专题 —— React Today and Tomorrow Part II 视频中英双语字幕","text":"本文掘金地址：React Conf 2018 专题 —— React Today and Tomorrow Part II 视频中英双语字幕距离 React Conf 2018 结束已经将近一个月了，距离上个 React Conf 2018 的中英文双语视频发布也有两周的时间了，这两周，一直在进行Dan Abramov 的关于 React Hooks 提案部分演讲的字幕校对和翻译工作，感谢开源社区，这次加入了新的小伙伴 程序媛_小发 一起完成了校对和翻译的工作，让这段视频可以更快的和大家见面。 视频简介话不多说，先放上视频地址：React Today And Tomorrow Part II —— Dan’s Keynote 中英双语字幕 第一部分视频地址：React Today And Tomorrow Part I —— Sophie’s Keynote 中英双语字幕 2018年11月30日更新，小发已经把前两部分视频上传到 b 站上了，没广告特别好，视频地址：【React Conf 2018】React 的今天和明天中英文双字幕 简单介绍一下视频的内容，该视频是 React Conf 2018 的开场演讲，题目为 React Today and Tomorrow。 本视频为该演讲的第二部分，在上个视频中 Sophie Alpert 对 React Today 做出了总结并引出了当前 React 面临的三大问题，本视频中 Dan Abramov 为我们带来解决这三个问题的方法 —— React Hook，正式发表 React Hook 提案，并宣布 Hook 是 React 的未来。外号“Demo Boy ”的 Dan 在本次大会上除了颇多的 Demo 之外，在视频的结尾处，Dan 有一段我特别喜欢的个人演讲，他从 React 的 Logo 讲起，类比了组件与原子、Hook 与电子的关系，告诉我们他认为 Hook 并不是一个新特性，它一直就在那里，就在 React Logo 中电子所在的轨道上。非常精彩的演讲，值得一看。 这里放一张 Twitter 里比较火的 Dan 忘记绑定时的报错动图： 因为这个演讲 Demo 部分比较多，强烈建议大家观看视频。另外如果看视频不方便的同学，该演讲的图文版文稿正在整理中，过两天会发布出来。第一部分视频内容文稿可以移步到这篇文章：[译] React 的今天和明天（图文版） —— 第一部分。 背景两周前在 掘金翻译计划 校对了一篇 Dan Abramov 的关于 React Hooks 的文章，在 Sophie Alpert 和 Dan 在 React Conf 2018 上对 Hooks 的提案之后， Hooks 非常火。想到由于原视频在 Youtube 上的原因导致大部分小伙伴没法观看，而且官方没有提供英文字幕，YouTube 里面的英文字幕是机器自动生成的，错误比较多也没有断句，所以想把 React Conf 2018 的视频中英文字幕配好供大家一起学习。我看B站上已经搬运了 React Conf 2018 的全套视频，大家可以去围观。 总结第一次听译字幕的体验真的非常神奇，这段视频已经翻来覆去看了几十遍了，记忆比较深的是一个句子听了将近一百遍才听出来。比起第一段视频10 分钟校对翻译花了 10 个小时，第二段 49 分钟的视频速度明显快了很多，再次感谢小发的帮助，我们分工完成了这个大工程的工作。 之前在掘金翻译计划也翻译和校对了好几篇文章了，做字幕的工作又是全新的体验，因为大部分时间花在了听视频校对英文字幕上。在听力环节，理解视频的内容会对英文校对有很大的帮助，有一句是一直没有听出来的句子，后来看到下文 Dan 又换了一个说法提到，回过头来终于听清楚了原来是有个 Ryan 的人名，Ryan 是大会的第三个演讲者。在翻译方面，已经越来越游刃有余了，这几个月又把英语和语文捡了起来，还算很有成就感的事情。 传送门 最重要的 React 官方文档：Introducing Hooks [译] React 的今天和明天（图文版） —— 第一部分 [译] React 的今天和明天（图文版） —— 第二部分 前两部分视频地址（B 站）：【React Conf 2018】React 的今天和明天中英文双字幕 第一部分视频地址（爱奇艺）：React Today And Tomorrow Part I —— Sophie’s Keynote 中英双语字幕 第二部分视频地址（爱奇艺）：React Today And Tomorrow Part II —— Dan’s Keynote 中英双语字幕 Dan 对本次演讲的精炼文章（需要科学上网）：Making Sense of React Hooks 上面文章的译文：[译] 理解 React Hooks 一篇非常好的理解 React Hook 的文章：30 分钟精通 React Hooks 如果发现中英文字幕存在错误或其他需要改进的地方，欢迎到本项目的 GitHub 仓库 对英文字幕或译文进行修改并 PR，谢谢大家。当然后本视频还有后面 Ryan 给我带来的第三段题目为90% Cleaner React with Hooks 的演讲，欢迎有兴趣的小伙伴一起参与英文字幕校对和翻译工作。 原视频地址：React Today and Tomorrow and 90% Cleaner React with Hooks 演讲者: Dan Abramov 英文字幕出自：YouTube 机器翻译 英文字幕校对、翻译：Ivocin, 程序媛_小发","link":"/2018/11/27/React_today_and_tomorrow_video2/"},{"title":"使用 Eject 方式在 create-react-app 中使用 Ant Design of React","text":"Ant Design 官网对 如何 react-app-rewired 的方式进行按需加载进行了说明，详见 在 create-react-app 中使用 一文，文中有这样一段话 你也可以使用 create-react-app 提供的 yarn run eject 命令将所有内建的配置暴露出来。不过这种配置方式需要你自行探索，不在本文讨论范围内。 本文主要就Eject方式进行探索 使用create-react-app创建项目 参考：如何扩展 Create React App 的 Webpack 配置 的Eject方式 首先使用create-react-app创建一个项目1$ create-react-app antd-test 创建完项目后，进入项目目录，执行 yarn run eject 或 npm run eject 1$ npm run eject 执行后会出现提示，该操作不可逆，选择y继续 成功eject后会暴露webpack的配置,package.json增加了很多的依赖 安装antd使用 cnpm 安装 antd1$ cnpm install antd 修改，引入 antd 的按钮组件。1234567891011121314151617```javascriptimport React, { Component } from &apos;react&apos;;import Button from &apos;antd/lib/button&apos;;import &apos;./App.css&apos;;class App extends Component { render() { return ( &lt;div className=&quot;App&quot;&gt; &lt;Button type=&quot;primary&quot;&gt;Button&lt;/Button&gt; &lt;/div&gt; ); }}export default App; 执行npm install 安装依赖，并启动项目 12$ cnpm install$ npm start 启动之后发现button并没有样式，需要引入antd的css文件 修改 ```antd/dist/antd.css```。123456789```javascript@import &apos;~antd/dist/antd.css&apos;;.App { text-align: center;}... 使用 babel-plugin-import 按需引入 antd 样式在文件顶部引入 antd 组件的样式（对前端性能是个隐患）。123[babel-plugin-import](https://github.com/ant-design/babel-plugin-import) 是一个用于按需加载组件代码和样式的 babel 插件（[原理](http://ant-design.gitee.io/docs/react/getting-started-cn#%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD)）```bash$ cnpm install babel-plugin-import --save-dev 修改12345```diff...- import Button from &apos;antd/lib/button&apos;;+ import { Button } from &apos;antd&apos;;... 然后移除前面在 里全量添加的 ```@import '~antd/dist/antd.css';``` 123456789101112131415此时发现按钮样式不生效了，最简单的方式是修改```package.json```文件里的babel配置, 增加babel-plugin-import的配置```diff... &quot;babel&quot;: { &quot;presets&quot;: [ &quot;react-app&quot;- ]+ ],+ &quot;plugins&quot;: [+ [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; }]+ ] }... 重新执行npm start，样式重新生效 至此使用Eject方式按需引入antd的方式已经探索完毕。","link":"/2018/07/29/create_react_app_antd_eject/"},{"title":"React 工程的 VS Code 插件及配置","text":"最近使用 VS Code 来开发 React，本文记录一些使用的 VS Code 插件以及离线安装插件的方法。 VS Code 插件的离线安装内网环境的开发需要考虑插件的离线开发，参考了简单的 VSCode 插件离线安装方法，发现官方以及很贴心的提供了下载插件的方式，总结下来一共3步： 进入 VS Code Market，搜索需要的插件 点击Download Extension，下载下来的是.vsix格式文件 安装VS Code时配置好了环境变量，在控制台执行 code --install-extension your-extension-name.vsix 即可安装 一些实用的插件 适用于 VS Code 的中文（简体）语言包 ： 地址： Chinese (Simplified) Language Pack for Visual Studio Code 英文好的同学可以不必安装本插件 一个下载量最多的 VS Code 主题插件： One Dark Pro 地址： One Dark Pro ESLint: 地址： ESLint Debugger for Chrome： 地址：Debugger for Chrome 可以和 WebStorm 一样打断点了 路径自动补全插件： Path Intellisense 地址：Path Intellisense 虽然 VS Code 自带了自动补全路径功能，html文件没有问题，但是在 JSX 里有些文件无法智能提示（比如 JSX 里面的 img 的 src ），本插件很好用，相对路径绝对路径都没有问题 JSON工具： JSON Tools 地址： JSON Tools 格式化JSON很方便，只需两个快捷键: 格式化JSON Ctrl(Cmd)+Alt+M, 压缩JSON Alt+M CSS 智能提示插件： IntelliSense for CSS class names in HTML 地址： IntelliSense for CSS class names in HTML 本插件已经支持className 和 class (TypeScript React, JavaScript and JavaScript React language modes) 暂不支持 css module 智能提示 CSS Module 智能提示 地址： CSS Modules 本插件可以解决 IntelliSense for CSS class names in HTML 不支持 css module 智能提示的功能 可以实现 css 自动补全、转到定义位置 括号颜色匹配： Bracket Pair Colorizer 地址： Bracket Pair Colorizer 使用颜色来配对括号 Bookmarks 地址： Bookmarks 将常用的位置添加到书签，可以极大提高效率 React/Redux/react-router Snippets 地址： React/Redux/react-router Snippets React 的代码段，熟悉了之后很方便 JSX 中使用 Emmet 快速补全标签 VS Code 自带了 Emmet，可以自动补全 HTML 文件中的标签 想要补全 react 文件中 JSX 里面的标签，需要在用户设置中增加 Emmet 的设置： 123456789{ ... // 在默认不支持 Emmet 的语言中启用 Emmet 缩写功能。在此添加该语言与受支持的语言间的映射。 // 示例: {&quot;vue-html&quot;: &quot;html&quot;, &quot;javascript&quot;: &quot;javascriptreact&quot;} &quot;emmet.includeLanguages&quot;: {&quot;javascript&quot;: &quot;javascriptreact&quot;}, // 启用后，按下 TAB 键，将展开 Emmet 缩写。 &quot;emmet.triggerExpansionOnTab&quot;: true ...} 其中emmet.triggerExpansionOnTab配置为true可以使用 TAB 键自动补全组件标签了 可以自动将class转为className，很方便 关于格式化插件感觉自带的代码格式化功能基本够用了，就没安装 Prettier 和 Beautify，Beautify反而还会把react里面的jsx格式化弄乱。 参考资料 强大的 VS Code 简单的 VSCode 插件离线安装方法","link":"/2018/08/01/vs_code_tools_for_react/"},{"title":"[译] 5 款工具助力 React 快速开发","text":"原文地址：5 Tools for Faster Development in React 原文作者：Jonathan Saring 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/5-tools-for-faster-development-in-react.md 译者：Ivocin 校对者：Haoze Xu, Junkai Liu 本文掘金地址：[译] 5 款工具助力 React 快速开发 本文将会介绍 5 款工具，可加速 React UI 组件和应用程序的开发工作。 React 非常适合快速开发具有出色的交互式 UI 的应用程序。React 组件是创建用于开发不同应用的隔离的、可复用的模块的很棒的方法。。 虽然一些最佳实践有助于开发更好的应用程序，但正确的工具可以使开发过程更快。以下是 5（+）个实用的工具，可以帮助我们加速组件和应用程序的开发。 欢迎你发表评论并提出建议。 1. Bit Bit — 分享和构建组件代码：Bit 帮助你在不同的项目和应用程序中共享、发现和使用代码组件，以构建新功能和… Bit 是一个开源平台，用于使用组件构建应用程序。 使用 Bit，你可以组织来自不同应用程序和项目的组件（无需任何重构），并使其可以在构建新功能和应用程序时被发现、使用、开发和协作。 YouTube 视频链接：https://youtu.be/P4Mk_hqR8dU Bit 上共享的组件可自动地通过 NPM/Yarn 安装，或与 Bit 本身一起使用。后者使你能够同时开发来自不同项目的组件，并轻松更新（并合并）它们之间的更改。 为了使组件更容易被发现，Bit 为组件提供了可视化渲染，测试结果（Bit 独立运行组件的单元测试）和从源代码本身解析的文档。 使用 Bit，你可以更快地开发多个应用程序和进行团队协作，并将你的组件用作新功能和项目的构建块。 2. StoryBook / StyleguidistStorybook 和 Styleguidist 是在 React 中快速开发 UI 的环境。两者都是加速 React 应用程序开发的绝佳工具。 两者之间存在一些重要的差异，这些差异也可以组合在一起以完成你的组件开发系统。 使用 Storybook，你可以在 JavaScript 文件中编写 stories。使用 Styleguidist，你可以在 Markdown 文件中编写示例。Storybook 一次显示一个组件的变化，而 Styleguidist 可以显示不同组件的多种变化。Storybook 非常适合显示组件的状态，而 Styleguidist 对于不同组件的文档和演示非常有用。 下面是一个简短的纲要。 StoryBook storybooks/storybook: storybook — Interactive UI component dev &amp; test: React, React Native, Vue, Angular. Storybook 是 UI 组件的快速开发环境。 它允许你浏览组件库，查看每个组件的不同状态，以及交互式开发和测试组件。 StoryBook 可帮助你独立于应用程序开发组件，这也有助于提高组件的可重用性和可测试性。 你可以浏览库中的组件，修改其属性，并通过热加载在网页上获得组件的即时效果。可以在这里找到一些流行的例子。 不同的插件可以帮助你更快地开发，从而缩短代码调整到视觉输出之间的周期。StoryBook 还支持 React Native 和 Vue.js。 Styleguidist React Styleguidist：具有在线样式指南的独立的 React 组件开发环境：具有在线样式指南的独立的 React 组件开发环境。 React Styleguidist 是一个组件开发环境，它具有热重载的开发服务器和在线样式指南，列出组件的 propTypes 并显示基于 .md 文件的可编辑的用法示例。 它支持ES6，Flow 和 TypeScript，并且可以使用开箱即用的 Create React App。自动生成的使用文档可以让 Styleguidist 充当团队不同组件的文档门户。 另请查看由 Formidable Labs 提供的 React Live。这个组件渲染环境也用在了 Bit 的实时组件 playground 上。 3. React devTools 这个官方的 React Chrome devTools 扩展程序可以让你在 Chrome 开发者工具里查看 React 组件的层次结构。它也可以作为 FireFox 附加组件使用。 使用 React devTools，你可以在操作组件树时查看并编辑组件的 props 和 state。此功能可以让你了解组件更改如何影响其他组件，以帮助你使用正确的组件结构和分离方式来设计 UI。 这个扩展程序的搜索栏可让你快速查找和检查所需的组件，从而节省宝贵的开发时间。 查看适用于 Safari，IE 和 React Native 的独立应用程序。 4. Redux devTools 此 Chrome 扩展程序（和 FireFox 附加组件）是一个开发时间程序包，是 Redux 开发工作流程的利器。它允许你检查每个 state 和 action payload，重新计算“分阶段”的 actions。 你可以将 Redux DevTools 扩展程序 与任何处理状态的体系结构集成。每个 React 组件的本地状态可以有多个存储或不同的实例。你甚至可以通过“时间旅行”来取消 actions（可以观看 Dan Abramov 的 视频）。日志记录 UI 本身甚至可以自定义为 React 组件。 5. Boilerplates &amp; Kick-Starters虽然这些并不完全是开发者工具，但它们有助于快速创建 React 应用程序，同时节省构建和其他配置的时间。虽然 React 有许多入门套件，但这里有一些最好的。 当与预制组件（在 Bit 或其他来源上）结合使用时，你可以快速创建应用程序结构并将组件组合到其中。 Create React App (50k stars) 这个广泛使用且受欢迎的项目可能是快速创建新 React 应用程序并从头开始运行的最有效方法。 此软件包封装了新 React 应用程序所需的复杂配置（Babel，Webpack等），因此你可以节省新建应用程序所需的这段时间。 要创建新应用程序，只需运行一个命令即可。 1npx create-react-app my-app 此命令在当前文件夹中创建名为 my-app 的目录。在目录中，它将生成初始项目结构并安装传递依赖项，然后你就可以简单地开始编码了。 React Boilerplate (18k stars)Max Stoiber 的这个 React 样板文件模板为你的 React 应用程序提供了一个启动模板，该模板专注于离线开发，并在考虑到了可扩展性和性能。 它的快速脚手架有助于直接从 CLI 创建组件、容器、路由、选择器和 sagas —— 以及它们的测试，而 CSS 和 JS 的更改可以立即反映出来。 与 create-react-app 不同，这个样板文件不是为初学者设计的，而是为经验丰富的开发人员提供的。使用它可以管理性能、异步、样式等等，从而构建产品级的应用程序。 React Slingshot (8.5k stars)Cory House 的这个极好的项目是 React + Redux 入门套件/样板，带有Babel、热重载、测试和 linting 等等。 与 React Boilerplate 非常相似，这个入门套件专注于快速开发的开发人员体验。每次点击“保存”时，更改都会热重载，并且会运行自动化测试。 该项目甚至包括一个示例应用，因此你无需阅读太多文档即可开始工作。 另外也可以了解一下 simple-react-app，这篇文章对此工具进行了解释。 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。","link":"/2018/12/27/5_Tools_for_Faster_Development_in_React/"},{"title":"[译] React 的今天和明天（图文版） —— 第一部分","text":"原视频地址：React Today and Tomorrow and 90% Cleaner React with Hooks 中英文字幕视频地址（B站）：【React Conf 2018】React 的今天和明天中英文双字幕 中英文字幕视频地址（爱奇艺）：React Today And Tomorrow Part I —— 中英双语字幕 英文原文地址：React Today and Tomorrow - Part I 中文译文（无图版）地址：React 的今天和明天—— 第一部分 演讲者： Sophie Alpert 英文字幕出自：YouTube 机器翻译 英文校对、翻译、排版：Ivocin 本文掘金地址：[译] React 的今天和明天（图文版） —— 第一部分 2018年 11 月 30 日更新，第二部分已经更新：[译] React 的今天和明天（图文版） —— 第二部分 。前两部分中英双语字幕视频已经发布：【React Conf 2018】React 的今天和明天中英文双字幕。 React 的今天和明天 —— 第一部分 早上好。大家好，欢迎来到 React 大会。今天来到这里我感到非常激动。我非常高兴可以给你们做开场演讲。 我是 Sophie Alpert，个人主页是 sophiebits.com。我是 Facebook 的 React 核心小组的开发经理。 React 的今天你们正在使用的 React 做的很好。我们在 npm 的下载量一年内增加了 70%。 React Dev Tools 在 Chrome 开发者工具扩展程序的安装量达到了 125 万。 这是使用 React 的公司列表。此时此刻，这个列表已经非常长了，我们很难说清每年使用 React 的公司的变化。 我们来看另一组数据，我们来看看 Google 趋势, 它可以反映出网络搜索的流量。可以看到，React 的搜索量一直在增加。 希望这个数据表示有更多的人在使用 React，而不是 React 变得更加令人困惑了。（笑声） 嗯，为了做比较，我们比较了 jQuery 的搜索量，我们的搜索量刚刚在历史上首次超越了 jQuery。（欢呼和掌声）但这也表明，我们仍然有很多成长的空间。 我在写这个演讲时被耽搁了一会儿。 因为我比较好奇 React 还比什么更流行。 哎呀。（笑声）当我开了个玩笑。嗯，我发现 React 比可再生能源（renewable energy）更流行。（笑声） React 也比橙汁（orange juice）更流行。（笑声）想想橙汁是多么常用啊，是吧。 而且 React 比可再生能源和橙汁加在一起更流行。所以我认为我们有理由感到非常自豪。 React 的使命但是除了这些数字，我今天真正想要讲的是 React 的使命。呃，自从 2013 年 React 发布以来，我们首要的目标和使命就是：让开发者更容易地构建好的 UI。 所以当我们想要增加新的特性时，我们通常都是要经过深思熟虑。当我们决定是否增加新的 API 时，我们需要考虑非常多的事情。如果增加新的 API 能够让你做到一些以前做不到的事情；如果可以显著简化组件里的代码和类库，让你的工作量减小，用户下载更少的代码，那新增 API 就是有价值的。或者如果新增 API 能够帮助我们做到代码分割的最佳实践，如果能够更容易地将你 app 里面的代码分割成多个包，我们希望你的 app 最终可以运行更快。这也是我们两周之前宣布增加像 React.lazy 这样的API 的原因。 你们可能已经注意到了这个 API。 但想想 React 的使命，让开发者更容易地构建好的 UI。我们有很多方法来实现这个目标。 其中一点是我们尝试简化复杂的东西。如果你看了 Dan Abramov 在冰岛的 JS Conf 上的演讲，你可以抢先看到 “Suspense”, “Suspense” 是我们用来显著简化 app 中获取数据请求、代码分割和异步数据依赖的问题。 另外一个我们尝试去提升 React 的方式就是提升性能。如果你的 app 运行速度更快，你的用户就会更原意使用它。相反的，如果你的 app 反应很慢，速度卡顿，那你的用户肯定不会有很好的体验。因此我们尝试让 React 本身运行的更快，如果 React 开箱就很快，那么你们就会省下很多优化你自己代码的时间。 最近和提升性能有关的内容，Dan 也在冰岛的 JS Conf 上提到了，我们称其为 “Time Slicing”。”Time Slicing” 可以确保你 app 里面最重要的渲染会最先执行，解除主线程的阻塞，并且能让你的 app 运行地更快速。 第三种方式是使用开发者工具帮助你 debug ，进而更了解你的 app。一开始，React 就包含了对开发者友好的警告来帮助开发者指出问题，以防开发者没有注意到这些问题。 而且我们的 React Dev Tools 扩展程序能够让你检查并且 debug 你的组件树。 在 React 16.5 版本，我们引入了一个叫 Profiler 的新特性。它是第二个 … （我不知道这个遥控器出了什么问题）… 图上的第二个标签栏就是 profiler 标签栏， 它能够帮助我们了解到你的 app 中到底发生了什么，然后更好地优化它。 所以 Suspense, Time Slicing 和 Profiler 这三个新特性是我们去年一直在做的事情。 我们真的想多说一些关于这三个特性的内容。但是这些并不是我今天在这里想要讲的。大家可以等到明天，Andrew 和 Brian 会在明天早上给大家带来关于这个内容的演讲。 React 还存在什么糟糕的地方现在我想退一步，让我们来关注一些其他的问题。我想问的是，现在 React 还有什么糟糕的地方。我总结出了三个问题，想在这里和大家讨论。 逻辑复用第一个问题就是多组件间的逻辑复用问题。 在 React 中我们主要使用组件来构建我们的应用，组件主要有两种主要的模式来复用代码：它们是高阶组件（higher-order components）和渲染属性（render props)。 这两种模式对于某些场景来说是很好的，但是它们也造成了一个极大的缺点。在更加复杂的场景中，你必须将他们抽离出来去重构你的 app。这会导致一个问题，我称之为”包装地狱“（wrapper hell）。 嗯，我们经常会看到像这样的组件树。（尖叫和笑声）而且这种嵌套会造成跟踪 app 数据流的困难。如果能够复用这类有状态的逻辑，而不需要修改组件的层级，那肯定是很好的方法，对吧。 庞大的组件第二个我想讲的问题是庞大的组件，它的逻辑杂乱无章。 我们来看看一个上千行代码的 React 组件，我们会发现逻辑分散到了许多不同的生命周期函数中，这样非常难以跟踪。 我们来看一个例子。这里有一个 class 组件，在它的 componentDidlMount 方法，它做了几件事：它订阅了一个数据存储，然后发送了一个网络请求，最后开启了一个定时器。 那么，如果我们来看 componentWillUnmount 方法，我们会看到基本完全相反的代码：首先需要取消订阅存储，然后取消网络请求，最后停止定时器。 当我们要实现 componentDidUpdate 方法, 里面的逻辑会更加的 tricky。因为你需要比较新旧的属性，然后再一次重复和其他生命周期函数内部相同的任务逻辑。 呃，在这个例子里，每个请求都只有一行，所以说这个例子实际上比你平时看到的组件要简单的多。在真实组件中，逻辑往往会更加错综复杂，因为每个独立的任务分散到了不同的生命周期函数中，这样会造成困难，举个例子，当你 unmounting 组件时，你可能会忘记清除资源，这非常难以从代码中找到问题。 令人困惑的 Class第三个糟糕的事情是 Class。理解 JavaScript 里的 class 会相当 tricky，而且为了能够使用 state 和生命周期，我们要求你们使用 class 组件才能做到。 如果你用过 function 组件，并且将其转为了 class 组件，并增加了一些 state，你就会知道这个过程需要有大量的样板文件，但是其作用仅仅是用来定义一个 class 组件。大多数初学者以及很多有经验的开发者也都跟我们抱怨过在 class 里面的绑定和转化工作相当令人困惑。我们有必要来关注这个问题。 而且我们经常听说大家并不是非常清楚什么时候使用 function 组件，有一部分原因是他们总会担心早晚需要将这个组件转化为 class 组件。所以你们可能会困惑，我现在是否应该这么做？我不知道。 所以我说 class 对于人类来说是很难的，但是不仅仅对于人类而言是这样，我认为 class 对于机器而言也是同样很难。 如果你看过压缩后的组件文件，可以看到所有的方法名没有被压缩。而且如果你有一个完全没有被使用的方法，它也没有被剔除出去。这是因为在编译时很难准确判断方法是否被使用。 我们还发现 class 使得可靠的热加载变得困难。最后当我们设计一个优化的编译器原型来提升 React 组件性能时，我们发现 class 组件的一些模式使得编译器优化变得更加困难。 总结所以，我们现在有三个问题：逻辑复用、庞大的组件和 Class。逻辑复用的问题会导致你经常遇到“包装地狱”。庞大组件的原因是由于逻辑分散到了不同的生命周期中。而令人困惑的 class 无论对于人类还是机器来说都是个难题。 我们认为我们有了一个能够解决以上三个问题的解决方案。我们特别想把这个方案分享给大家。请允许我请出 Dan Abramov 为我们带来接下来的演讲。 传送门 最重要的 React 官方文档：Introducing Hooks [译] React 的今天和明天（图文版） —— 第一部分 中英文字幕视频地址（B站）：【React Conf 2018】React 的今天和明天中英文双字幕 第一部分视频地址（爱奇艺）：React Today And Tomorrow Part I —— Sophie’s Keynote 中英双语字幕 第二部分视频地址（爱奇艺）：React Today And Tomorrow Part II —— Dan’s Keynote 中英双语字幕 Dan 对本次演讲的精炼文章（需要科学上网）：Making Sense of React Hooks 上面文章的译文：[译] 理解 React Hooks 一篇非常好的理解 React Hook 的文章：30 分钟精通 React Hooks 希望看本文视频的同学，可以查看我的这篇文章：React Conf 2018 专题 —— React Today and Tomorrow PART I 视频中英双语字幕，中英双语字幕已经给大家准备好了。我们的 Demo Boy —— Dan Abramov 后面关于 React Hooks 的精彩演讲正在翻译中，欢迎有兴趣的同学联系我一起翻译，让更多的小伙伴能够更快看到 React Conf 2018 的精彩内容。","link":"/2018/11/12/React_today_and_tomorrow1/"},{"title":"create-react-app 创建项目有关 less 的若干问题","text":"在上篇文章使用Eject方式在 create-react-app 中使用 Ant Design of React中， 使用create-react-app创建了React项目，并使用Eject方式暴露出了Webpack的配置，并成功按需引入了antd。本文主要内容：解决create-react-app创建项目后less不生效的问题；antd按需引入less源文件，以及遇到的bezierEasing.less文件报错问题；antd本地字体的配置方法；less使用css module的配置。 直接引入less样式不生效创建test.less，并在App.js中引入123.test { color: red;} 1234567// App.js...import './test.less'... &lt;div className=\"test\"&gt;test&lt;/div&gt; &lt;Button type=\"primary\"&gt;Button&lt;/Button&gt;... 发现test的颜色并没有生效 安装 less 和 less-loader ，并修改Webpack配置1$ cnpm i less less-loader --save-dev 修改webpack配置修改 webpack.config.dev.js 和 webpack.config-prod.js 配置文件, 增加less文件配置: 123456789101112131415161718// webpack.config.dev.js... { test: /\\.less$/, use: [ require.resolve('style-loader'), { loader: require.resolve('css-loader'), options: { importLoaders: 1, }, }, { loader: require.resolve('less-loader') // compiles Less to CSS } ], },... 重启项目后，less样式已经生效 antd 的样式使用 less 源文件方式引入在babel-plugin-import 中对style有这样对说明： [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot; }] : import js modularly [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: true }] : import js and css modularly (LESS/Sass source files) [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: &quot;css&quot; }] : import js and css modularly (css built files) 修改package.json，将style的值改为true1234567891011... &quot;babel&quot;: { &quot;presets&quot;: [ &quot;react-app&quot; ] ], &quot;plugins&quot;: [ [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: true }] ] }... 重启之后，编译错误，提示bezierEasing.less文件的.bezierEasingMixin()方法报错： 按照报错提供的issue地址查看 ： https://github.com/ant-design/ant-motion/issues/44主要有2种解决方式 将 less 版本降到 3.0 以下, 应该可行，降级的方法感觉不太好，没有测试 less loader 增加配置，开启 JavaScript ：12345678910// webpack.config.dev.js... {- loader: require.resolve('less-loader') // compiles Less to CSS+ loader: require.resolve('less-loader'), // compiles Less to CSS+ options: {+ javascriptEnabled: true+ } } 重新npm start，项目可以正常启动。 antd使用本地字体 iconfont 2018年9月5日更新，9月开学季， ant design 系列迎来了一系列的重大更新。umi 迎来了 2.0 版本， 随之而来的是 ant design pro 使用 umi 2.0 构建的 2.0 版本。 今天注意到 ant design 的 3.9.0 版本一个重大的更新是对 Icon 进行了重构， 使用 SVG 代替之前的 css font icon。所以如果使用 ant design 3.9.0 以上的版本， 就不会存在离线找不到字体文件的问题了。如果你使用的 ant design 在 3.9.0 版本以下，可以参考下文离线使用 iconfont 的方式。 Ant Design 默认的 iconfont 文件托管在 iconfont.cn 并默认使用平台提供的 alicdn 地址，公网可访问使用。 由于 alicdn 对部分域名有访问限制，或者需要内网环境使用，需要将字体下载到本地 最新的 iconfont 文件可以到 此链接 下载。 下载后将字体文件放入 public/iconfont/ 路径下 由于项目使用的是create-react-app创建项目，且antd的样式使用babel-plugin-import按需加载样式，所以只能采用 定制主题中的less-loader的modifyVars配置来覆盖原来的样式变量。 具体改动修改 webpack.config.dev.js 和 webpack.config-prod.js 配置文件1234567891011// webpack.config.dev.js... { loader: require.resolve('less-loader'), // compiles Less to CSS options: { javascriptEnabled: true， modifyVars: { \"icon-url\": \"'/public/iconfont/iconfont'\" } } } 重启项目，成功引入了本地字体 需要注意的是webpack.config-prod.js文件中的icon-url路径需要将public替换为生产环境项目文件路径，打包之后public中的文件和文件夹直接复制到bulid路径下。使用相对路径会报错无法编译，这点不知道有没有更好的处理方式，希望读者大神们提供更好的方式。 1234567891011// webpack.config-prod.js... { loader: require.resolve('less-loader'), // compiles Less to CSS options: { javascriptEnabled: true， modifyVars: { \"icon-url\": \"'/your-project-name/iconfont/iconfont'\" } } } css module 形式引入less增加12345678910111213141516171819202122232425```diff { test: /\\.less$/, // exclude: [/node_modules/], use: [ require.resolve(&apos;style-loader&apos;), { loader: require.resolve(&apos;css-loader&apos;), options: { importLoaders: 1,+ modules: true }, }, { loader: require.resolve(&apos;less-loader&apos;), // compiles Less to CSS options: { javascriptEnabled: true, modifyVars: { &quot;icon-url&quot;: &quot;&apos;/public/iconfont/iconfont&apos;&quot; } } } ], }, 修改App.js，使用css module方式引入 1234567891011121314- import './test.less'+ import styles from './test.less' class App extends Component { render() { return ( &lt;div className=\"App\"&gt;- &lt;div className=\"test\"&gt;test&lt;/div&gt;+ &lt;div className={styles.test}&gt;test&lt;/div&gt; &lt;Button type=\"primary\"&gt;Button&lt;/Button&gt; &lt;/div&gt; ); } } 重启项目,css module引入的test样式生效了，但是antd的按钮样式失效了 需要修改 webpack.config.dev.js，只对src中的less文件开启css module，这里写法有点麻烦，应该有更好的方式。 1234567891011121314151617181920212223242526272829303132333435363738// webpack.config.dev.js... { test: /\\.less$/, use: [ require.resolve('style-loader'), { loader: require.resolve('css-loader'), options: { importLoaders: 1 }, }, { loader: require.resolve('less-loader'), // compiles Less to CSS options: { javascriptEnabled: true, modifyVars: { \"icon-url\": \"'/public/iconfont/iconfont'\" } } } ], }, { test: /\\.less$/, include: [/src/], use: [ require.resolve('style-loader'), { loader: require.resolve('css-loader'), options: { importLoaders: 1, modules: true }, } ], },... 2018-08-02更新，评论区有兄弟留言说重新npm install后，css module引入的样式失效了，今天测试了一下确实有这个问题，试着改了上面的对less文件处理的loader顺序可以解决这个问题，但是原理不是很清楚，还请了解原理的兄弟帮忙指点，多谢 1234567891011121314151617181920212223242526272829303132333435363738// webpack.config.dev.js... { test: /\\.less$/, include: [/src/], use: [ require.resolve('style-loader'), { loader: require.resolve('css-loader'), options: { importLoaders: 1, modules: true }, } ], }, { test: /\\.less$/, use: [ require.resolve('style-loader'), { loader: require.resolve('css-loader'), options: { importLoaders: 1 }, }, { loader: require.resolve('less-loader'), // compiles Less to CSS options: { javascriptEnabled: true, modifyVars: { \"icon-url\": \"'/public/iconfont/iconfont'\" } } } ], },... 总结本文在eject的create-react-app的项目基础上，按需引入了antd，遇到了有关less的若干问题：解决了less文件不生效的问题，内网环境使用本地iconfont的配置方式，css module的配置方式。本文还有一些配置方式不是最优的方式，希望各位能够给出更好的方案。 最近在起步React，准备记录以下自己的学习和踩坑过程。下一篇文章应该是dva的使用。 参考资料 https://github.com/ant-design/antd-init/tree/master/examples/local-iconfont Antd定制主题 create-react-app项目添加less配置 如何在react中使用antd+less+css modules [译] react-css-modules","link":"/2018/07/30/create_react_app_less_issues/"},{"title":"DvaJS 的学习之路 1 - dva+umi 官网例子学习","text":"前置知识 dva roadhog umi dva知识地图 使用 umi 改进 dva 项目开发 umi + dva，完成用户管理的 CURD 应用 本文主要是在 dva 作者 @sorrycc 的例子 umi + dva，完成用户管理的 CURD 应用基础上进行的一些自己的学习记录。关于评论区的小伙伴说的照抄 @sorrycc 大神的github文章的问题，这里回应下，没错，本文 90% 以上的文字都出自 umi + dva，完成用户管理的 CURD 应用 这篇文章，而且作者和文章出处一开始就交代清楚了，写这个文章的目的是记录一下自己跟着教程 step by step 完成这个应用的过程，并不是教程，期望教程的小伙伴， @sorrycc 大大在 dva 官网上提供了很多丰富的例子，可以参考。 2018年9月10日更新，umi 已经升级到了 2.0 版本，希望使用 umi@2 开发的同学请移步至 DvaJS的学习之路2 - umi@2 + dva，完成用户管理的 CURD 应用。 开始之前： 确保 node 版本是 8.4 或以上 用 cnpm 或 yarn 能节约你安装依赖的时间 Step 1. 安装 dva-cli@next 并创建应用先安装 dva-cli，并确保版本是 1.0.0-beta.2 或以上。1234$ cnpm i dva-cli@next -g$ dva -vdva-cli version 1.0.0-beta.4 dva version 2.3.1 这里需要注意的是安装dva-cli@next版本的原因是目前 umi 还未提供官方的脚手架工具，需要 dva + umi 结合使用可以使用 dva-cli@next 方式来初始化项目。详见：例子和脚手架。 然后创建应用： 12$ dva new user-dashboard$ cd user-dashboard Step 2. 配置代理，能通过 RESTFul 的方式访问 http://localhost:8000/api/users修改 .umirc.js ，加上 “proxy” 配置：1234567proxy: { &quot;/api&quot;: { &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com/&quot;, &quot;changeOrigin&quot;: true, &quot;pathRewrite&quot;: { &quot;^/api&quot; : &quot;&quot; } }}, 然后启动应用：(这个命令一直开着，后面不需要重启) 1$ npm start 浏览器会自动开启，并打开 http://localhost:8000。 访问 http://localhost:8000/api/users ，就能访问到 http://jsonplaceholder.typicode.com/users 的数据。(由于 typicode.com 服务的稳定性，偶尔可能会失败。不过没关系，正好便于我们之后对于出错的处理) Step 3. 生成 users 路由umi 中文件即路由，所以我们要新增路由，新建文件即可，详见 https://umijs.org/guide/router.html 。 新建 src/pages/users/page.js，内容如下： 1234567export default () =&gt; { return ( &lt;div&gt; Users Page &lt;/div&gt; )} 然后访问 http://localhost:8000/users ，你会看到 Users Page 的输出。 注意：使用 umi 约定 src/pages 目录下的文件即路由，而文件则导出 react 组件。可以看到 umi 的特点：以页面维度，将 models 、 services 组织到一起。 Step 4. 构造 users model 和 service新增 service: src/pages/users/services/users.js： 12345import request from &apos;../../../utils/request&apos;;export function fetch({ page = 1 }) { return request(`/api/users?_page=${page}&amp;_limit=5`);} 注意这里的 page 参数默认为 1，limit 参数设置为 5 新增 model: src/pages/users/models/users.js，内容如下： 1234567891011121314151617181920212223242526272829import * as usersService from &apos;../services/users&apos;;export default { namespace: &apos;users&apos;, state: { list: [], total: null, }, reducers: { save(state, { payload: { data: list, total } }) { return { ...state, list, total }; }, }, effects: { *fetch({ payload: { page } }, { call, put }) { const { data, headers } = yield call(usersService.fetch, { page }); yield put({ type: &apos;save&apos;, payload: { data, total: headers[&apos;x-total-count&apos;] } }); }, }, subscriptions: { setup({ dispatch, history }) { return history.listen(({ pathname, query }) =&gt; { if (pathname === &apos;/users&apos;) { dispatch({ type: &apos;fetch&apos;, payload: query }); } }); }, },}; 这里面有一些写法之前没有用过：比如{ payload: { data: list, total } }, 这个是析构时配 alias 的写法；return { ...state, list, total } 的写法用了Spread Operator ... 来组合新对象, 详见 dva知识地图#ES6对象和数组 由于我们需要从 response headers 中获取 total users 数量，所以需要改造下 src/utils/request.js： 12345678910111213141516171819202122232425262728293031323334353637import fetch from &apos;dva/fetch&apos;;function checkStatus(response) { if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) { return response; } const error = new Error(response.statusText); error.response = response; throw error;}/** * Requests a URL, returning a promise. * * @param {string} url The URL we want to request * @param {object} [options] The options we want to pass to &quot;fetch&quot; * @return {object} An object containing either &quot;data&quot; or &quot;err&quot; */export default async function request(url, options) { const response = await fetch(url, options); checkStatus(response); const data = await response.json(); const ret = { data, headers: {}, }; if (response.headers.get(&apos;x-total-count&apos;)) { ret.headers[&apos;x-total-count&apos;] = response.headers.get(&apos;x-total-count&apos;); } return ret;} 注意：这里使用了 ES7 的 async/await 特性，开始对这块不是很熟悉，看了一些关于 async/await 的文章，发现确实比 Promise 的写法语义化更加明显，下面这段是我改写的 Promise 写法： 123456789101112131415161718192021/** * Requests a URL, returning a promise. * * @param {string} url The URL we want to request * @param {object} [options] The options we want to pass to &quot;fetch&quot; * @return {object} An object containing either &quot;data&quot; or &quot;err&quot; */export default function request(url, options) { let headers = {} return fetch(url, options) .then(checkStatus) .then(response =&gt; { const data = parseJSON(response) if (response.headers.get(&apos;x-total-count&apos;)) { headers[&apos;x-total-count&apos;] = response.headers.get(&apos;x-total-count&apos;); } return data; }).then((data) =&gt; { return {data, headers} }).catch(err =&gt; ({ err }));} 切换到浏览器（会自动刷新），应该没任何变化，因为数据虽然好了，但并没有视图与之关联。但是打开 Redux 开发者工具，应该可以看到 users/fetch 和 users/save 的 action 以及相关的 state 。 Step 5. 添加界面，让用户列表展现出来我们把组件存在 src/pages/users/components 里，所以在这里新建 Users.js 和 Users.css。具体参考这个 Commit。 需留意两件事： 对 model 进行了微调，加入了 page 表示当前页 由于 components 和 services 中都用到了 pageSize，所以提取到 src/constants.js 改完后，切换到浏览器，应该能看到带分页的用户列表。 有几点需要注意： Users.js 里面使用了 antd 的组件，但是项目并没有手动安装 antd， 原来是 umi 帮我们引入了 antd 。 Users.js 里面将model和组件连接了起来，注意 const { list, total, page } = state.users; 里面的 users 为 model 里面的 namespace 名称。 我们没有手动注册 model，umi 帮我们进行了这一步操作， 详见 src/pages/.umi/DvaContainer.js 文件，该文件会自动更新。相关规则详见 umi官网#model注册 一节。 可以直接使用 css module Step 6. 添加 layout添加 layout 布局，使得我们可以在首页和用户列表页之间来回切换。umi 里约定 layouts/index.js 为全局路由，所以我们新增 src/layouts/index.js 和 CSS 文件即可。 参考这个 Commit。 注意： 页头的菜单会随着页面切换变化，高亮显示当前页所在的菜单项 Step 7. 处理 loading 状态dva 有一个管理 effects 执行的 hook，并基于此封装了 dva-loading 插件。通过这个插件，我们可以不必一遍遍地写 showLoading 和 hideLoading，当发起请求时，插件会自动设置数据里的 loading 状态为 true 或 false 。然后我们在渲染 components 时绑定并根据这个数据进行渲染。 umi-plugin-dva 默认内置了 dva-loading 插件。 然后在 src/components/Users/Users.js 里绑定 loading 数据：1+ loading: state.loading.models.users, 具体参考这个 Commit 。 刷新浏览器，你的用户列表有 loading 了没? Step 8. 处理分页只改一个文件 src/pages/users/components/Users.js 就好。 处理分页有两个思路： 发 action，请求新的分页数据，保存到 model，然后自动更新页面 切换路由 (由于之前监听了路由变化，所以后续的事情会自动处理) 我们用的是思路 2 的方式，好处是用户可以直接访问到 page 2 或其他页面。 参考这个 Commit 。 Step 9. 处理用户删除经过前面的 8 步，应用的整体脉络已经清晰，相信大家已经对整体流程也有了一定了解。 后面的功能调整基本都可以按照以下三步进行： service model component我们现在开始增加用户删除功能。 service, 修改 src/pages/users/services/users.js： 12345export function remove(id) { return request(`/api/users/${id}`, { method: &apos;DELETE&apos;, });} model, 修改 src/pages/users/models/users.js： 12345*remove({ payload: id }, { call, put, select }) { yield call(usersService.remove, id); const page = yield select(state =&gt; state.users.page); yield put({ type: &apos;fetch&apos;, payload: { page } });}, component, 修改 src/pages/users/components/Users.js，替换 deleteHandler 内容： 1234dispatch({ type: &apos;users/remove&apos;, payload: id,}); 切换到浏览器，删除功能应该已经生效。 Step 10. 处理用户编辑处理用户编辑和前面的一样，遵循三步走： service model component先是 service，修改 src/pages/users/services/users.js：123456export function patch(id, values) { return request(`/api/users/${id}`, { method: &apos;PATCH&apos;, body: JSON.stringify(values), });} 再是 model，修改 src/pages/users/models/users.js：12345*patch({ payload: { id, values } }, { call, put, select }) { yield call(usersService.patch, id, values); const page = yield select(state =&gt; state.users.page); yield put({ type: &apos;fetch&apos;, payload: { page } });}, 最后是 component，详见 Commit。 需要注意的一点是，我们在这里如何处理 Modal 的 visible 状态，有几种选择： 存 dva 的 model state 里 存 component state 里 另外，怎么存也是个问题，可以： 只有一个 visible，然后根据用户点选的 user 填不同的表单数据 几个 user 几个 visible此教程选的方案是 2-2，即存 component state，并且 visible 按 user 存。另外为了使用的简便，封装了一个 UserModal 的组件。 完成后，切换到浏览器，应该就能对用户进行编辑了。 Step 11. 处理用户创建相比用户编辑，用户创建更简单些，因为可以共用 UserModal 组件。和 Step 10 比较类似，就不累述了，详见 Commit 。 到这里，我们已经完成了一个完整的 CURD 应用。如果感兴趣，可以进一步看下 dva 和 umi 的资料： dva 官网 umi 官网 （完） 总结做这个练习主要了解了 dva 和 umi 搭配使用的方式，使用 umi 的一些写法和 umi 的特点。感觉学习了 Redux 之后，dva 上手会很快，dva 的网站资源很丰富，希望和大家一起学习，后续还会有 dva 学习的文章。","link":"/2018/08/06/dva_learning1/"},{"title":"[译] 从 2010 到 2018，你不知道的关于网页滚动和用户注意力的变化","text":"原文地址：Scrolling and Attention 原文作者：Therese Fessenden 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/scrolling-and-attention.md 译者：Ivocin 校对者：Moonliujk, CoderMing 摘要： 人们比以前更多地纵向滚动网页，但是新的眼动追踪数据表明：注意力没有变化，人们仍然更关注首屏上的内容，而非首屏以下的内容。 人们的行为相当的稳定，可用性指南一直鲜有变化。但是，从网络出现早期至今，有一个用户行为发生了变化，那就是滚动网页的趋势。一开始，很少有人纵向滚动网页，但到了 1997 年，随着长页面的普及，大多数人学会了滚动网页。然而，首屏上的信息仍然受到了最多的关注：我们的眼动追踪研究表明，即使早在 2010 年，用户 80% 的页面浏览时间都花在了首屏上面。 自 2010 年以来，随着响应式设计和极简主义的出现，许多设计师转向了具有负空间的长页面（覆盖几个“屏幕”）设计。现在是时候再次探究由于这些网页设计趋势的普及，用户行为是否发生了变化。 眼动追踪数据关于本研究为了回答这个问题，我们分析了 1920×1080 分辨率屏幕上超过 130,000 个凝视点（eye fixations）的 x, y 坐标。这些凝视点来自 120 名参与者，他们是我们最近的眼动追踪研究的一部分，该研究涉及来自各行各业的数千个网站。在本研究中，我们重点分析了广泛的用户任务，这些任务涵盖各种页面和行业，包括新闻，电子商务，博客，常见问题解答和百科全书页面。我们的目标不是分析某个网站，而是总结出用户行为的一般性。 我们将这些近期数据与我们之前在眼动追踪研究中获得的数据进行了比较，之前的数据是在 1024×768 分辨率屏幕上获得的。 研究结果我们的前后两次研究之间发生了两处变化：（a）更大的屏幕，（b）用户可能已经适应了的新的网页设计趋势。我们无法单独考虑某一变化所带来的影响。但没有关系，因为两者都是由于时间的流逝造成的变化。即使我们想要，我们也无法撤消任何一个。 在我们最近的一项研究中，用户将大约 57% 的页面浏览时间用于首屏。74% 的浏览时间花费在前两个屏幕上，浏览的长度最高可达 2160px。（本分析不关心页面的最大长度 —— 结果可能是由于页面长度较短或者是用户在浏览了前两个屏幕内容后就放弃了阅读。） 这些发现与我们在2010 年的发表的文章完全不同：在那篇文章中，用户 80% 的页面浏览时间花费在了首屏。然而首屏后页面关注度急剧下降的现象在 2018 年和 2010 年相同。 首屏上的内容在浏览时间中占据比最高。大约 74% 的时间花费在前两个屏幕内容中（首屏加上首屏下方的屏幕信息）。剩余的 26% 部分随着页面长度的增加少量递减。 能够理解的是，并非每个页面的长度都相同。为了确定人们如何在页面上分配他们的注意力（无论页面有多长），我们将页面分成 20％ 的分段（即每页的五分之一）。在一般网站上，超过 42% 的浏览时间花在了页面的前 20% 区域上，超过 65% 的浏览时间花在页面的前 40% 区域上。在搜索结果页面（SERPs）上，结合我们在 2010 年的调查结果，47% 的浏览时间花费在页面的前 20% 区域上（超过 75% 的浏览时间花在了页面的前 40% 区域上）—— 可能反映了用户更愿意查看热门搜索结果的现象。 人们花费更多时间浏览页面的前 20% 区域。 如果我们只关注首屏的内容 —— 在第一个屏幕中 —— 屏幕顶部的信息比底部信息更受关注。用户超过 65% 的浏览时间集中在视窗的上半部分。在 SERP 上，首屏超过 75% 的浏览时间花费在了第一个屏幕的上半部分。（这是一个古老的事实，但也是老生常谈：你在谷歌的搜索结果要么是前两名，要么就在互联网上几乎不存在。“轻信谷歌”的现象至今依然强烈，和我们 10 年前发现这种用户行为时一样。） 即便在首屏上，注意力也集中在页面顶部 —— 尤其是 SERP。 浏览和阅读模式我们已经发现首屏上的内容得到了最多的关注（占浏览时间的 57%），第二屏内容浏览时间约占三分之一（占浏览时间的 17%），剩余的 26% 浏览时间表现为长尾分布。换言之，一条信息离页面顶部越近，它被阅读的可能性就越大。 个人阅读模式证实了这一发现。许多用户在扫描内容结构不合理的页面时会使用 F 模式阅读 —— 他们倾向于更仔细地查看靠近页面顶部的文本（文本的前几段），页面越往下阅读信息的时间越少。 即使网页是列表形式或信息以结构化的方式呈现，人们也会在页面顶部投注更多的目光（即阅读时间），因为他们需要了解页面的组织方式。一旦他们这样做，他们倾向有效地关注与手头任务相关的信息，因此在远离顶部的内容上投注更少的目光（即阅读时间）。 这是一个典型的凝视图，图中显示大多数用户的凝视点都集中在页面的顶部，但并不总是位于最顶部。凝视点的实际分布取决于页面的具体设计和用户访问页面的目标。如果信息看起来很有趣，用户有时可能会阅读一点点，但总体而言，浏览会在页面的下方逐渐消失。 2010 年 vs 现在2010 年，用户 80% 的浏览时间都花在了首屏上。今天，这个数字只有 57% —— 可能是由于长页面普遍流行的结果。这意味着什么？ 首先，总的来说，设计师们很好地创造了指示符以抵消页面完整的错觉，并引导人们滚动页面。换言之，他们了解了长页面的缺点并在一定程度上缓解了这些缺点。其次，它可能意味着用户已经习惯了滚动阅读 —— 需要滚动阅读的页面的流行让滚动页面植入到了用户的行为中。 至少在某种程度上。人们仍然不会滚动很多 —— 他们几乎不会滚动到三屏之外。基本上，首屏的界限已经被推到了第三个屏幕 —— 8 年前，用户浏览网页时间的 80％ 的停留在了在第一个屏幕信息中（首屏）；而今天，用户浏览网页时间的 81％ 停留在了前三个屏幕上。 我们总是说人们会在有理由的情况下滚动页面。人们的注意力仍然停留在页面顶部 —— 页面顶部是网页内容中最易发现且可能被用户查看的部分。滚动页面的交互成本使用户几乎不会阅读较长页面下游部分的内容。 有趣的是，屏幕分辨率的增加并没有像人们预期的那样导致滚动的减少。原因可能是设计师和开发者没有利用更大的屏幕来减少滚动，而选择将内容进一步分散。无论好坏，现在鼓励用户滚动网页比过去更多 —— 但不能更多了。在网络的早期，信息密度可能太高了（这导致了拥挤和杂乱的布局），但现在的页面设计绝对是太稀疏了。 启示鉴于用户在页面的顶部花费了更多的阅读时间，特别是在首页上，这里有一些你需要记住的事情： 将高优先级内容放到页面顶部：关键业务和用户目标。页面的下半部分可以放置次要信息或相关信息。将主要的 CTA 放到首屏。 重要的内容使用合适的字体样式来引起用户注意：用户根据标题和粗体文本等元素来识别信息的重要程度，并且定位新的内容片段。确保这些元素在视觉上与众不同，并在整个网站中保持风格统一，以便用户可以轻松地找到它们。 注意不要使用“假地板”，这在现代简约设计中越来越常见。完整性的错觉可能会干扰滚动。包括指示符（例如截断的文本），告诉人们下面还有内容。 通过用户代表测试您的设计，以确定“理想的”页面长度，并确保用户能够轻松地查看到他们想要的信息。 结论虽然现代网页往往很长并且包含负空间，并且用户可能比过去更倾向于滚动页面，但人们仍然将大部分浏览时间花在了页面的顶部。内容优先级是您在内容规划过程中的关键步骤。强大的视觉指示符有时会诱使用户滚动页面并发现首屏以下的内容。要确定理想的页面长度，请与真实用户一起测试，并记住，很长的页面会增加失去客户注意力的风险。 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。","link":"/2018/10/23/scrolling_and_attention/"},{"title":"DvaJS 的学习之路 2 - umi@2 + dva，完成用户管理的 CURD 应用","text":"前言最近一个月来使用 dva 对公司存量项目进行重构，比较少时间写文章了。随着9月开学季节的到来，最近在使用的几个开源项目都迎来了重大更新。首先就是 umi 终于迎来了 2.0 版本，具体介绍可以查看 发布 umi 2.0，可插拔的企业级 react 应用框架。随之而来的是使用 umi@2 构建的 ant design pro 2.0 版本，具体介绍可以查看漂亮的实力派 Ant Design Pro 2.0 正式发布。今天终于有时间体验了 umi@2 ，想起我的 dva 学习之路的第一篇学习记录是使用 umi@1.X 构建的，刚好可以使用 umi 2.0 重新构建一下。本文是 dva 作者 @sorrycc 的 umi-dva-user-dashboard 的 umi@2 版本实现，是 《umi + dva，完成用户管理的 CURD 应用》 文章的 umi@2 版本改写。代码仓库： umi2-dva-user-dashboard。演示地址：demo。 Step 1. 使用 create-umi 脚手架初始化项目详见 umi官网#通过脚手架创建项目 使用 yarn create 命令：12$ mkdir umi2-dva-user-dashboard &amp;&amp; cd umi2-dva-user-dashboard$ yarn create umi 看到社区有小伙伴问到如何使用 npm 创建 umi 项目，首先使用 npm 安装 create-umi : 1$ cnpm install -g create-umi 安装好之后，进入项目，然后执行 create-umi12$ cd umi2-dva-user-dashboard$ create-umi 注意官方推荐使用 yarn create 命令，因为能确保每次使用最新的脚手架。如果你和我一样，公司是内网开发环境只有 npm 私服，可以尝试使用 npm 命令。 完成上述操作后，进入 create-umi 交互式命令行，选择功能，这里选择 antd、dva 和 hard source 确定后，会根据你的选择自动创建好目录和文件： 然后手动安装依赖：1$ yarn 或1$ cnpm install 安装好依赖后启动项目：1$ yarn start 或1$ npm start 如果顺利，在浏览器打开 http://localhost:8000 可看到以下界面: Step 2. 配置代理，能通过 RESTFul 的方式访问 http://localhost:8000/api/users修改 .umirc.js ，加上 “proxy” 配置：1234567proxy: { &quot;/api&quot;: { &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com/&quot;, &quot;changeOrigin&quot;: true, &quot;pathRewrite&quot;: { &quot;^/api&quot; : &quot;&quot; } }}, 注意，代理配置与 umi@1 的配置相同。 访问 http://localhost:8000/api/users ，就能访问到 http://jsonplaceholder.typicode.com/users 的数据。 Step 3. 生成 users 路由umi 中文件即路由，所以我们要新增路由，新建文件即可，这里使用约定式路由。详见 https://umijs.org/zh/guide/router.html 。 新建 src/pages/users.js，内容如下： 1234567export default () =&gt; { return ( &lt;div&gt; Users Page &lt;/div&gt; )} 然后访问 http://localhost:8000/users ，你会看到 Users Page 的输出: 这里看到页面多出了一个头部，原来是 create-umi 脚手架生成的项目会默认生成一个全局 layout 文件 src/layouts/index.js, umi@1.X 版本就具有这个特性，详见官方文档全局layout Step 4. 构造 users model 和 service注意刚才建立的 src/pages/users.js 是简单的页面情况，目前需要和 model 与 service 组织到一起， 新建 src/pages/users/index.js 文件，将 src/pages/users.js 内容复制到 src/pages/users/index.js 文件中，然后删除 src/pages/users.js 文件。 create-umi 脚手架没有生成 request.js, 新建 src/utils/request.js： 12345678910111213141516171819202122232425262728293031323334353637import fetch from &apos;dva/fetch&apos;;function checkStatus(response) { if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) { return response; } const error = new Error(response.statusText); error.response = response; throw error;}/** * Requests a URL, returning a promise. * * @param {string} url The URL we want to request * @param {object} [options] The options we want to pass to &quot;fetch&quot; * @return {object} An object containing either &quot;data&quot; or &quot;err&quot; */export default async function request(url, options) { const response = await fetch(url, options); checkStatus(response); const data = await response.json(); const ret = { data, headers: {}, }; if (response.headers.get(&apos;x-total-count&apos;)) { ret.headers[&apos;x-total-count&apos;] = response.headers.get(&apos;x-total-count&apos;); } return ret;} 新增 service: src/pages/users/services/users.js，注意 umi@2 添加了 webpack alias @，指向 src 目录： 12345import request from &apos;@/utils/request&apos;;export function fetch({ page = 1 }) { return request(`/api/users?_page=${page}&amp;_limit=5`);} 注意这里的 page 参数默认为 1，limit 参数设置为 5 新增 model: src/pages/users/models/users.js，内容如下： 1234567891011121314151617181920212223242526272829import * as usersService from &apos;../services/users&apos;;export default { namespace: &apos;users&apos;, state: { list: [], total: null, }, reducers: { save(state, { payload: { data: list, total } }) { return { ...state, list, total }; }, }, effects: { *fetch({ payload: { page } }, { call, put }) { const { data, headers } = yield call(usersService.fetch, { page }); yield put({ type: &apos;save&apos;, payload: { data, total: headers[&apos;x-total-count&apos;] } }); }, }, subscriptions: { setup({ dispatch, history }) { return history.listen(({ pathname, query }) =&gt; { if (pathname === &apos;/users&apos;) { dispatch({ type: &apos;fetch&apos;, payload: query }); } }); }, },}; 切换到浏览器（会自动刷新），应该没任何变化，因为数据虽然好了，但并没有视图与之关联。但是打开 Redux 开发者工具，应该可以看到 users/fetch 和 users/save 的 action 以及相关的 state 。 Step 5. 添加界面，让用户列表展现出来（与umi@1相同）我们把组件存在 src/pages/users/components 里，所以在这里新建 Users.js 和 Users.css。具体参考这个 Commit。 需留意两件事： 对 model 进行了微调，加入了 page 表示当前页 由于 components 和 services 中都用到了 pageSize，所以提取到 src/constants.js 改完后，切换到浏览器，应该能看到带分页的用户列表。 有几点需要注意： Users.js 里面将 model 和组件连接了起来，注意 const { list, total, page } = state.users; 里面的 users 为 model 里面的 namespace 名称。 我们没有手动注册 model，umi 帮我们进行了这一步操作， 详见 src/pages/.umi/DvaContainer.js 文件，该文件会自动更新。相关规则详见 umi官网#model注册 一节。 可以直接使用 css module Step 6. 添加 Header Menu添加头部菜单组件，使得我们可以在首页和用户列表页之间来回切换。 参考这个 Commit。 Step 7. 处理 loading 状态（与umi@1相同）dva 有一个管理 effects 执行的 hook，并基于此封装了 dva-loading 插件。通过这个插件，我们可以不必一遍遍地写 showLoading 和 hideLoading，当发起请求时，插件会自动设置数据里的 loading 状态为 true 或 false 。然后我们在渲染 components 时绑定并根据这个数据进行渲染。 umi-plugin-dva 默认内置了 dva-loading 插件。 然后在 src/components/Users/Users.js 里绑定 loading 数据：1+ loading: state.loading.models.users, 注意这里的 users 为 model 的 namespace, 所以 dva-loading 的 loading 状态是对于 model 整体的。 具体参考这个 Commit 。 刷新浏览器，你的用户列表有 loading 了没? Step 8. 处理分页（与umi@1相同）只改一个文件 src/pages/users/components/Users.js 就好。 处理分页有两个思路： 发 action，请求新的分页数据，保存到 model，然后自动更新页面 切换路由 (由于之前监听了路由变化，所以后续的事情会自动处理) 我们用的是思路 2 的方式，好处是用户可以直接访问到 page 2 或其他页面。 quan参考这个 Commit 。 Step 9. 处理用户删除（与umi@1相同）经过前面的 8 步，应用的整体脉络已经清晰，相信大家已经对整体流程也有了一定了解。 后面的功能调整基本都可以按照以下三步进行： service model component我们现在开始增加用户删除功能。 service, 修改 src/pages/users/services/users.js： 12345export function remove(id) { return request(`/api/users/${id}`, { method: &apos;DELETE&apos;, });} model, 修改 src/pages/users/model.js： 12345*remove({ payload: id }, { call, put, select }) { yield call(usersService.remove, id); const page = yield select(state =&gt; state.users.page); yield put({ type: &apos;fetch&apos;, payload: { page } });}, component, 修改 src/pages/users/components/Users.js，替换 deleteHandler 内容： 1234dispatch({ type: &apos;users/remove&apos;, payload: id,}); 注意由于使用第三方api网站，数据并不会真的删除，只是删除api返回成功，选择删除后重新获取数据，仍然是原来的数据。 Step 10. 处理用户编辑（与umi@1相同）处理用户编辑和前面的一样，遵循三步走： service model component先是 service，修改 src/pages/users/services/users.js：123456export function patch(id, values) { return request(`/api/users/${id}`, { method: &apos;PATCH&apos;, body: JSON.stringify(values), });} 再是 model，修改 src/pages/users/model.js：12345*patch({ payload: { id, values } }, { call, put, select }) { yield call(usersService.patch, id, values); const page = yield select(state =&gt; state.users.page); yield put({ type: &apos;fetch&apos;, payload: { page } });}, 最后是 component，详见 Commit。 需要注意的一点是，我们在这里如何处理 Modal 的 visible 状态，有几种选择： 存 dva 的 model state 里 存 component state 里 另外，怎么存也是个问题，可以： 只有一个 visible，然后根据用户点选的 user 填不同的表单数据 几个 user 几个 visible此教程选的方案是 2-2，即存 component state，并且 visible 按 user 存。另外为了使用的简便，封装了一个 UserModal 的组件。 完成后，切换到浏览器，应该就能对用户进行编辑了。 Step 11. 处理用户创建（与umi@1相同）相比用户编辑，用户创建更简单些，因为可以共用 UserModal 组件。和 Step 10 比较类似，就不累述了，详见 Commit 。 到这里，我们已经完成了一个完整的 CURD 应用。如果感兴趣，可以进一步看下 dva 和 umi 的资料： dva 官网 umi 官网 （完） 总结本文主要使用umi@2来完成 umi-dva-user-dashboard 项目。可以看到在业务代码上，和umi@1的写法基本一致，迁移成本比较低。目前手头的项目正在使用dva进行重构，暂时还没有使用 umi@2 的计划，不过会持续关注 umi 的成长的。","link":"/2018/09/08/dva_learning2/"},{"title":"[译] Google 工程师提升网页性能的新策略：空闲执行，紧急优先","text":"原文地址：Idle Until Urgent 原文作者：PHILIP WALTON 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/idle-until-urgent.md 译者：Ivocin 校对者：xilihuasi，新舰同学 Xekin 本文掘金地址：[译] Google 工程师提升网页性能的新策略：空闲执行，紧急优先 几周前，我开始查看我网站的一些性能指标。具体来说，我想看看我的网站在最新的性能指标 —— 首次输入延迟 （FID）上的表现如何。 我的网站只是一个博客（并没有运行很多的 JavaScript），所以我原本预期会得到相当不错的结果。 用户一般对于小于 100 毫秒的输入延迟没有感知，因此我们推荐的性能目标（以及我希望在我的分析中看到的数字）是对于 99％ 的页面加载，FID 小于 100 毫秒。 令我惊讶的是，我网站 99% 的页面的 FID 在 254 毫秒以内。我是个完美主义者，尽管结果不算很糟糕，但我却无法对这个结果置之不理。我一定得把它搞定！ 简而言之，在不删除网站的任何功能的情况下，我把 99% 页面的 FID 降到了 100 毫秒以内。但我相信读者朋友们更感兴趣的是： 我是如何诊断问题的。 我采用了什么具体的策略和技术。 说到上文中的第二点，当时我试图解决我的问题时，偶然发现了一个非常有趣的性能策略，特别想分享给大家（这也是我写这篇文章的主要原因）。 我把这个策略称作：空闲执行，紧急优先。 我的性能问题首次输入延迟（FID）是一个网站性能指标，指用户与网站首次交互（像我这样的博客，最有可能的首次交互是点击链接）和浏览器响应此交互（请求加载下一页面）之间的时间。 存在延迟是由于浏览器的主线程正在忙于做其他事情（通常是在执行 JavaScript 代码）。因此，要诊断这个高于预期的 FID，我们首先需要在网站加载时启动性能跟踪（启用 CPU 降频和网络限速），然后在主线程上找到耗时长的任务。一旦确定了这些耗时长的任务，我们就可以尝试将它们拆解为更小的任务。 以下是我在对网站启用性能跟踪后的发现： 我的网站加载时的 JavaScript 性能跟踪图（启用网络限速和 CPU 降频）。 可以注意到，主要脚本包在浏览器中单独执行时，它需要耗时 233 毫秒才能完成。 运行我网站的主要脚本包耗时 233 毫秒。 在这些代码中，一部分来自 webpack 样板文件和 babel polyfill，但大多数代码来自我脚本的 main() 入口函数，它本身需要 183 毫秒才能完成： 执行我网站的 main() 入口函数耗时 183 毫秒。 这并不像是我在 main() 函数中做了什么荒谬的事情。在 main() 函数中，我先初始化了我的 UI 组件，然后运行了我的 analytics 方法： 12345678910const main = () =&gt; { drawer.init(); contentLoader.init(); breakpoints.init(); alerts.init(); analytics.init();};main(); 那么是什么花了如此长时间运行？ 我们继续来看一下这个火焰图的尾部，可以看到没有一个函数占据了大部分时间。绝大多数函数耗时不到 1 毫秒，但是当你将它们全部加起来时，在单个同步调用堆栈中，运行它们却需要超过 100 毫秒。 JavaScript 就像被“千刀万剐”了一样。 由于这些功能全都作为单个任务的一部分运行，因此浏览器必须等到此任务完成才能响应用户的交互。一个十分明显的解决方案是将这些代码拆解为多个任务，但这说起来容易做起来难。 乍一看，明显的解决方案是将 main() 函数中的每个组件分配优先级（它们实际上已经按优先级顺序排列了），立即初始化优先级最高的组件，然后将其他组件的初始化推迟到后续任务中。 虽然这可能有一些作用，但它的可操作行并不强，而且难以应用到大型网站中。原因如下： 推迟 UI 组件初始化的方法仅在组件尚未渲染时才有用。推迟初始化组件的方法会造成风险：用户有可能遇到组件没有渲染完成的情况。 在许多情况下，所有 UI 组件要么同等重要，要么彼此依赖，因此它们都需要同时进行初始化。 有时单个组件需要足够长的时间来初始化，即使它们各自在自己的任务中运行，也会阻塞主线程。 实际情况是，通常我们很难让每个组件在各自的任务中初始化，而且这种做法往往不可能实现。我们经常需要的是在每个组件内部的初始化过程中拆解任务。 贪婪的组件从下面的性能跟踪图可以看出，我们是否真的需要把组件初始化代码进行拆分，让我们来看一个比较好的例子：在 main() 函数的中间，你会看到我的一个组件使用了 Intl.DateTimeFormat API： 创建一个 Intl.DateTimeFormat 实例需要 13.47 毫秒！ 创建此对象需要 13.47 毫秒！ 问题是，虽然 Intl.DateTimeFormat 实例是在组件的构造函数中创建的，但实际上在其他组件用它来格式化日期之前，它都没有被使用过。可是由于该组件不知道何时会引用 Int.DateTimeFormat 对象，因此它选择立即初始化该对象。 但这是正确的代码求值策略吗？如果不是，那什么是正确的代码求值策略？ 代码求值策略在选择求值策略时，大多数开发人员会从如下两种策略中做出选择： 立即求值： 你可以立即运行耗时的代码。 惰性求值： 等到你的程序里的其他部分需要这段耗时代码的结果时，再去运行它。 这两种求值策略可能是目前最受欢迎的，但在我重构了我的网站后，我认为这两个策略可能是最糟糕两个选择。 立即求值的缺点从我网站上的性能问题可以很好地看出，立即求值有一个缺点：如果用户在代码运行时与你的页面进行交互，浏览器必须等到代码运行完成后才能做出响应。 当你的页面看起来已经准备好响应用户输入却无法响应时，这个问题尤为突出。用户会感觉你的页面很卡，甚至以为页面彻底崩溃了。 预先运行的代码越多，页面交互所需的时间就越长。 惰性求值的缺点如果立即运行所有代码是不好的，那么一个显而易见的解决方案就是等到需要的时候再运行。这样就不会提前运行不必要的代码，尤其是一些从未被使用过的代码。 当然，等到用户需要的时候再运行的问题是：你必须确保你的高耗时的代码能够阻止用户输入。 对于某些情况（比如另外加载网络资源），将其推迟到用户请求时再加载是有意义的。但对于你的大多数代码（例如从 localStorage 读取数据，处理大型数据集等等）而言，你肯定希望它在用户交互之前就执行完毕。 其他选择其他可选择的求值策略介于立即求值和惰性求值之间。我不确定以下两种策略是否有官方名称，我把它们称作延迟求值和空闲求值： 延迟求值： 使用 setTimeout 之类的函数，在后续任务中来执行你的代码。 空闲求值： 一种延迟求值策略，你可以使用像 requestIdleCallback 这样的 API 来组织代码运行。 这两个选项通常都比立即求值或惰性求值好，因为它们不太可能由于单个长任务阻塞用户输入。这是因为，虽然浏览器不能中断任何单个任务来响应用户输入（这样做很可能会破坏网站），但是它们可以在计划任务队列之间运行任务，而且大多数浏览器会优先处理由用户输入触发的任务。这称为输入优先。 换句话说：如果确保所有代码都运行在耗时短、不同的任务中（最好小于 50 毫秒），你的代码就再也不会阻塞用户输入了。 重要！ 虽然浏览器能够在任务队列中优先执行输入回调函数，但是浏览器无法将这些输入回调函数在排列好的微任务之前运行。由于 promise 和 async 函数作为微任务运行，将你的同步代码转换为基于 promise 的代码不会起到缓解用户输入阻塞的作用。 如果你不熟悉任务和微任务之间的区别，我强烈建议你观看我的同事杰克关于事件循环的精彩演讲。 鉴于我刚才所说的，可以使用 setTimeout() 和requestIdleCallback() 来重构我的 main() 函数，将我的初始化代码拆解为单独的任务： 12345678910const main = () =&gt; { setTimeout(() =&gt; drawer.init(), 0); setTimeout(() =&gt; contentLoader.init(), 0); setTimeout(() =&gt; breakpoints.init(), 0); setTimeout(() =&gt; alerts.init(), 0); requestIdleCallback(() =&gt; analytics.init());};main(); 然而，虽然这比以前更好（许多小任务 vs. 一个长任务），正如我上文解释的那样，它可能还不够好。例如，如果我延迟我 UI 组件（特别是 contentLoader 和 drawer）的初始化过程，虽然它们几乎不会阻塞用户输入，但是当用户尝试与它们交互时，它们也存在未准备好的风险！ 虽然使用 requestIdleCallback () 来延迟我的 analytics 方法可能是一个好主意，但在下一个空闲时间之前我关心的任何交互都将被遗漏。而且如果在用户离开页面之前，浏览器都没有空闲时间，这些回调函数可能永远不会运行！ 因此，如果所有这些求值策略都有缺点，那么我们该作何选择呢？ 空闲执行，紧急优先在长时间思考这个问题之后，我意识到我真正想要的求值策略是：先把代码推迟到空闲时间执行，但是一旦代码被调用则立即执行。换句话说：“空闲执行，紧急优先”。 “空闲执行，紧急优先”的策略回避了我在上一节中指出的大多数缺点。在最坏的情况下，它与延迟计算具有完全相同的性能特征；在最好的情况下，它完全不会阻塞用户交互，因为在空闲时间里，代码都已经执行完毕了。 我还得提一点，这个策略既适用于单任务（在空闲时间求值），也适用于多任务（创建一个有序的任务队列，可以空闲时间运行队列中的任务）。我先解释一下单任务（空闲值）变体，因为它更容易理解。 空闲值我在上文提到过，初始化 Int.DateTimeFormat 对象可能非常耗时，因此若不需要立即调用该实例，最好在空闲时间去初始化。当然，一旦需要它，你就希望它已经存在了。所以这是一个可以用“空闲执行，紧急优先”策略来解决的完美的例子。 如下是我们重构以使用新策略的简化版组件的例子： 12345678910111213class MyComponent { constructor() { addEventListener(&apos;click&apos;, () =&gt; this.handleUserClick()); this.formatter = new Intl.DateTimeFormat(&apos;en-US&apos;, { timeZone: &apos;America/Los_Angeles&apos;, }); } handleUserClick() { console.log(this.formatter.format(new Date())); }} 上面的 MyComponent 实例在其构造函数中做了两件事： 为用户交互添加事件侦听器。 创建 Intl.DateTimeFormat 对象。 该组件很好地说明了为什么我们经常需要在单个组件内部拆解任务（而不仅仅在组件级别拆解任务）。 在这种情况下，事件监听器立即运行非常重要，但在事件处理函数需要之前，创建 Intl.DateTimeFormat 实例是不必要的。当然我们也不想在事件处理函数中创建Intl.DateTimeFormat 对象，因为这样会使事件处理函数变得很慢。 下面就是使用“空闲执行，紧急优先”策略修改后的代码。需要注意的是，这里使用了 IdleValue 帮助类，后续我会进行讲解： 1234567891011121314151617import {IdleValue} from &apos;./path/to/IdleValue.mjs&apos;;class MyComponent { constructor() { addEventListener(&apos;click&apos;, () =&gt; this.handleUserClick()); this.formatter = new IdleValue(() =&gt; { return new Intl.DateTimeFormat(&apos;en-US&apos;, { timeZone: &apos;America/Los_Angeles&apos;, }); }); } handleUserClick() { console.log(this.formatter.getValue().format(new Date())); }} 如你所见，此代码和先前的版本没有太大的区别，但在新代码中，我没有将 this.formatter 赋值给新的Intl.DateTimeFormat 对象，而是将 this.formatter 赋值给了 IdleValue 对象，在 IdleValue 内部进行 Intl.DateTimeFormat 的初始化过程。 IdleValue 类的工作方式是调度初始化函数，使其在浏览器的下一个空闲时间运行。如果空闲时间在引用 IdleValue 实例之前，则不会发生阻塞，而且可以在请求时立即返回该值。但另一方面，如果在下一个空闲时间之前引用了 IdleValue 实例，则取消初始化函数在空闲时间中的调度任务，并且立即运行初始化函数。 下面是如何实现 IdleValue 类的要点（注意：我已经发布了这段代码，它是idlize 包的一部分，idlize 里面包含了本文出现的所有帮助类)： 12345678910111213141516171819export class IdleValue { constructor(init) { this._init = init; this._value; this._idleHandle = requestIdleCallback(() =&gt; { this._value = this._init(); }); } getValue() { if (this._value === undefined) { cancelIdleCallback(this._idleHandle); this._value = this._init(); } return this._value; } // ...} 虽然在上面的示例中包含 IdleValue 类并不需要很多修改，但是它在技术上改变了公共 API（ this.formatter vs. this.formatter.getValue()）。 如果你无法修改公共 API，但是还想要使用 IdleValue 类，则可以将 IdleValue 类与 ES2015 的 getters 一起使用： 1234567891011121314151617class MyComponent { constructor() { addEventListener(&apos;click&apos;, () =&gt; this.handleUserClick()); this._formatter = new IdleValue(() =&gt; { return new Intl.DateTimeFormat(&apos;en-US&apos;, { timeZone: &apos;America/Los_Angeles&apos;, }); }); } get formatter() { return this._formatter.getValue(); } // ...} 或者，如果你不介意抽象一点，你可以使用 defineIdleProperty() 帮助类（底层使用的是 Object.defineProperty()）： 123456789101112131415import {defineIdleProperty} from &apos;./path/to/defineIdleProperty.mjs&apos;;class MyComponent { constructor() { addEventListener(&apos;click&apos;, () =&gt; this.handleUserClick()); defineIdleProperty(this, &apos;formatter&apos;, () =&gt; { return new Intl.DateTimeFormat(&apos;en-US&apos;, { timeZone: &apos;America/Los_Angeles&apos;, }); }); } // ...} 对于运行非常耗时的个别属性值，没有理由不使用此策略，特别是你不用为了使用此策略而去修改你的 API！ 虽然这个例子使用了 Intl.DateTimeFormat 对象，但如下情况使用本策略也是一个好的选择： 处理大量数据集。 从 localStorage（或 cookie）中获取值。 运行 getComputedStyle() 、getBoundingClientRect() 或任何其他可能需要在主线程上重绘样式或布局的 API。 空闲任务队列上文中的技术适用于可以通过单个函数计算出来的属性，但在某些情况下，逻辑可能无法写到单个函数里，或者，即使技术上可行，您仍然希望将其拆分为更小的一些函数，以免其长时间阻塞主线程。 在这种情况下，我们真正需要的是一种队列，在浏览器有空闲时间时，可以安排多个任务（函数）按照顺序运行。队列将在可能的情况下运行任务，并且当需要回到浏览器时（比如用户正在进行交互）能够暂停执行任务。 为了解决这个问题，我构建了一个 IdleQueue 类，可以像这样使用它： 123456789101112import {IdleQueue} from &apos;./path/to/IdleQueue.mjs&apos;;const queue = new IdleQueue();queue.pushTask(() =&gt; { // 一些耗时的函数可以在空闲时间运行...});queue.pushTask(() =&gt; { // 其他一些依赖上面函数的任务 // 耗时函数已经执行...}); 注意： 将同步的 JavaScript 代码拆解单独的任务和代码分割不同：前者被拆解的任务为可作为任务队列的一部分，并异步运行；而代码分割则是将较大的 JavaScript 包拆分为较小的文件的过程（它对于提高性能也很重要）。 与上面提到的的空闲时间初始化属性的策略一样，空闲任务队列也可以在需要立刻得到结果的情况下立即运行（“紧急”情况）。 同样，最后一点非常重要；不仅仅因为有时我们需要尽快计算出某些结果，还有一个原因是我们通常都集成了同步的第三方 API，我们需要能够同步运行任务，以保证兼容性。 在理想的情况下，所有 JavaScript API 都是非阻塞的、异步的、代码量小的，并且由能够返回主线程。但在实际情况下，由于遗留的代码库或集成了无法控制的第三方库，我们通常别无选择，只能使用同步。 正如我之前所说，这是“空闲执行，紧急优先”策略的巨大优势之一。它可以轻松应用于大多数程序，而无需大规模重写架构。 保证紧急任务执行我在上文提到过，requestIdleCallback() 不能保证回调函数一定会执行。这也是我在与开发人员讨论 requestIdleCallback() 时，得到的他们不使用 requestIdleCallback() 的主要原因。在许多情况下，代码可能无法运行足以成为不使用它的理由 —— 开发人员宁愿保险地保持代码同步（即使会发生阻塞）。 网站分析代码就是一个很好的例子。网站分析代码的问题在于，很多情况下，在页面卸载时，网站分析代码就要运行（例如，跟踪外链点击等），在这种情况下，显然使用 requestIdleCallback() 不合适，因为回调函数根本不会执行。而且由于开发人员不清楚分析库的 API 在页面的生命周期中的调用时机，他们也倾向于求稳，让所有代码同步运行（这很不幸，因为从用户体验方面来说这些分析代码毫无作用）。 但是使用“空闲执行，紧急优先”模式来解决这个问题就很简单了。我们所要做的就是确保只要页面处于将要卸载的状态，就会立即运行队列中的网站分析代码。 如果你熟悉我近期发表在 Page Lifecycle API 的文章里面给出的建议，你就会知道在页面被终止或丢弃之前，最后一个可靠的回调函数是 visibilitychange 事件（因为页面的 visibilityState 属性会变为隐藏）。而且用户无法在页面隐藏的情况下进行交互，因此这正是运行空闲任务的最佳时机。 实际上，如果你使用了 IdleQueue 类，可以通过一个简单的配置项传递给构造函数，来启用该功能。 1const queue = new IdleQueue({ensureTasksRun: true}); 对于渲染等任务，无需确保在页面卸载之前运行任务，但对于保存用户状态和发送结束回话分析等任务，可以选择将此选项设置为 true。 注意： 监听 visibilitychange 事件应该足以确保在卸载页面之前运行任务，但是由于 Safari 的漏洞，当用户关闭选项卡时，页面隐藏和 visibilitychange 事件并不总是触发，我们必须实现一个解决方案来适配 Safari 浏览器。这个解决方案已经在 IdleQueue 类中为你实现好了，但如果你需要自己实现它，则需注意这一点。 警告！ 不要使用监听 unload 事件的方式来执行页面卸载前需要执行的队列。unload 事件不可靠，在某些情况下还会降低性能。有关更多详细信息，请参阅我在Page Lifecycle API 上的文章。 “空闲执行，紧急优先”策略的使用实例每当要运行可能非常耗时的代码时，应该尝试将其拆解为更小的任务。如果不需要立即运行该代码，但未来某些时候可能需要，那么这就是一个使用“空闲执行，紧急优先”策略的完美场景。 在你自己的代码中，我建议做的第一件事是查看所有构造函数，如果存在可能会很耗时的操作，使用 IdleValue 对象重构它们。 对于一些必需但又不用直接与用户交互的逻辑部分代码，请考虑将这些逻辑添加到 IdleQueue 中。不用担心，你可以在任何你需要的时候立即运行该代码。 特别适合使用该技术的两个具体实例（并且与大部分网站相关）是持久化应用状态（如 Redux）和网站分析。 注意： 这些使用实例的目的都是使任务在空闲时间运行，因此如果这些任务不立即运行则没有问题。如果你需要处理高优先级的任务，想要让它们尽快运行（但仍然优先级低于用户输入），那么requestIdleCallback() 可能无法解决你的问题。 幸运的是，我的几个同事开发出了新的 web 平台 API(shouldYield()和原生的 Scheduling API）可以帮助我们解决这个问题。 持久化应用状态我们来看一个 Redux 应用程序，它将应用程序状态存储在内存中，但也需要将其存储在持久化存储（如 localStorage）中，以便用户下次访问页面时可以重新加载。 大多数使用 localStorage 持久化存储状态的 Redux 应用程序使用了防抖技术，大致代码如下： 1234567891011121314let debounceTimeout;// 使用 1000 毫秒的抖动时间将状态更改保存到 localStorage 中。store.subscribe(() =&gt; { // 清除等待中的写入操作，因为有新的修改需要保存。 clearTimeout(debounceTimeout); // 在 1000 毫秒（防抖）之后执行保存操作， // 频繁的变化没有必要保存。 debounceTimeout = setTimeout(() =&gt; { const jsonData = JSON.stringify(store.getState()); localStorage.setItem(&apos;redux-data&apos;, jsonData); }, 1000);}); 虽然使用防抖技术总比什么都不做强，但它并不是一个完美的解决方案。问题是无法保证防抖函数的运行不会阻塞对用户至关重要的主线程。 在空闲时间执行 localStorage 写入会好得多。你可以将上述代码从防抖策略转换为“空闲执行，紧急优先”策略，如下所示： 1234567891011121314const queue = new IdleQueue({ensureTasksRun: true});// 当浏览器空闲的时候存储状态更改，// 为了避免多余地执行代码我们只存储最近发生的状态更改。store.subscribe(() =&gt; { // 清除等待中的写入操作，因为有新的修改需要保存。 queue.clearPendingTasks(); // 当空闲时执行保存操作。 queue.pushTask(() =&gt; { const jsonData = JSON.stringify(store.getState()); localStorage.setItem(&apos;redux-data&apos;, jsonData); });}); 请注意，此策略肯定比使用防抖策略更好，因为它能够保证即使用户离开页面之前将状态存储好。如果使用上面的防抖策略的例子，在用户离开页面的情况下，很有可能造成写入状态失败。 网站分析另一个“空闲执行，紧急优先”策略适合的实例就是网站分析代码。下面的例子教你如何使用 IdleQueue 类来发送你的网站分析数据，并且可以保证，即使用户关闭了标签页或跳转到了其他页面，并且还没有等到下次的空闲时间，这些数据也可以正常发送： 1234567891011121314const queue = new IdleQueue({ensureTasksRun: true});const signupBtn = document.getElementById(&apos;signup&apos;);signupBtn.addEventListener(&apos;click&apos;, () =&gt; { // 将其添加到空闲队列中，不再立即发送事件。 // 空闲队列能够保证事件被发送，即使用户 // 关闭标签页或跳转到了其他页面。 queue.pushTask(() =&gt; { ga(&apos;send&apos;, &apos;event&apos;, { eventCategory: &apos;Signup Button&apos;, eventAction: &apos;click&apos;, }); });}); 除了可以保证紧急情况之外，把这个任务添加到空闲时间队列也能够确保其不会阻塞响应用户点击事件的其他代码。 实际上，我建议将你所有的网站分析代码放到空闲时间执行，包括初始化代码。而且像 analytics.js 这样的库，其 API 已经支持命令队列，我们只需简单地在我们的 IdleQueue 实例上添加这些命令。 例如，你可以将默认的 analytics.js 初始化代码片段的最后一部分： 12ga(&apos;create&apos;, &apos;UA-XXXXX-Y&apos;, &apos;auto&apos;);ga(&apos;send&apos;, &apos;pageview&apos;); 修改为： 1234const queue = new IdleQueue({ensureTasksRun: true});queue.pushTask(() =&gt; ga(&apos;create&apos;, &apos;UA-XXXXX-Y&apos;, &apos;auto&apos;));queue.pushTask(() =&gt; ga(&apos;send&apos;, &apos;pageview&apos;)); (你也可以像我做的一样对 ga() 使用包装器，使其能够自动执行队列命令)。 requestIdleCallback 的浏览器兼容性在撰写本文时，只有 Chrome 和 Firefox 支持 requestIdleCallback()。虽然真正的 polyfill 是不可能的（只有浏览器可以知道它何时空闲），但是使用 setTimeout 作为一个备用方案还是很容易的（本文提到的所有帮助类和方法都使用这个备用方案）。 而且即使在不原生支持 requestIdleCallback() 的浏览器中，使用 setTimeout 这种备用方案也比不用强，因为浏览器仍然是优先处理用户输入，然后再处理通过 setTimeout() 函数创建的队列中的任务。 使用本策略实际上提高了多少性能？在本文开头我提到我想出了这个策略，因为我试图提高我网站的 FID 值。我尝试拆分那些页面开始加载就运行的代码，并且还得保证一些使用了同步 API 的第三方库（如 analytics.js）的正常运行。 上文已经提到，在我使用“空闲执行，紧急优先”策略之前，我所有初始化代码集中在了一个任务中，耗费了 233 毫秒。在使用了“空闲执行，紧急优先”策略之后，可以看到出现了更多耗时更短的任务。实际上，最长的一个任务也仅仅耗时 37 毫秒！ 我网站的 JavaScript 性能跟踪图，上面展示了很多短任务。 需要重点强调的是，使用新策略重构的代码和之前执行的任务的数量是相同的，变化仅仅是将其拆分为了多个任务，并且在空闲时间里执行它们。 因为所有任务都不超过 50 毫秒，所以没有任何一个任务影响我的交互时间（TTI），这对我的 lighthouse 得分很有帮助： 使用了“空闲执行，紧急优先”策略后，我的 lighthouse 报告。 最后, 由于本工作的目的是提高我网站的 FID, 在将这些变更上线之后, 经过分析，我非常兴奋地看到：对于 99% 的页面，FID 减少了 67%！ Code version FID (p99) FID (p95) FID (p50) Before idle-until-urgent 254ms 20ms 3ms After Idle-until-urgent 85ms 16ms 3ms 总结在理想情况下，我们的网站再也不会不必要地阻塞主线程了。我们会使用 web worker 来处理我们非 UI 的工作，而且我们还有浏览器内置好的 shouldYield() 和原生的 Scheduling API。 但在实际情况下，我们网站工程师往往没有选择，只能将非 UI 的代码放到主线程去执行，这导致了网页出现无响应的问题。 希望这篇文章已经说服了你，是时候去打破我们的长耗时 JavaScript 任务了。而且“空闲执行，紧急优先”策略能够把看起来同步的 API 转到空闲时间运行，能够和全部我们已知的和使用中的工具库结合，“空闲执行，紧急优先”是一个极好的解决方案。 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。","link":"/2018/11/04/Idle_Until_Urgent/"},{"title":"[译] React 的今天和明天（图文版） —— 第二部分","text":"原视频地址：React Today and Tomorrow and 90% Cleaner React with Hooks 中英文字幕视频地址（B站）：【React Conf 2018】React 的今天和明天中英文双字幕 中英文字幕视频地址（爱奇艺）：React Today And Tomorrow Part II —— 中英双语字幕 英文文稿地址：React Today and Tomorrow - Part II 演讲者: Dan Abramov 英文字幕出自：YouTube 机器翻译 英文校对、翻译：Ivocin, 程序媛_小发 排版：Ivocin 本文掘金地址：[译] React 的今天和明天（图文版） —— 第二部分 因为这个演讲 Dan 的 Demo 部分比较多，建议如果时间充裕，可以观看视频。希望看本文视频的同学，可以查看我的这篇文章：React Conf 2018 专题 —— React Today and Tomorrow Part II 视频中英双语字幕。第一部分 Sophie Alpert 的演讲图文版地址：[译] React 的今天和明天（图文版） —— 第一部分 React 的今天和明天 —— 第二部分嗨。我的名字是 Dan。我在 React Team 工作，这是我第一次参加 React 大会。 （掌声） React 当前面临的问题刚才 Sophie 讲述了这三个问题，我想大多数的开发者在 React 开发过程中都会遇到这些问题。当然，我们可以逐一来解决这些问题。我们可以尝试独立地去解决这些问题。但是实际上解决其中一个问题可能会使其他问题更加严重。 比如我们尝试解决“包装地狱”问题，可以将更多的逻辑放到组件里面，但是我们的组件会变得更大，而且更难以重构。另一个方面，如果我们为了方便重用，尝试将组件拆分为更小的片段，那么组件树的嵌套会更多了，而且最终又会以“包装地狱” 收场。最后，无论那种情况，使用 class 都会让人产生困惑。 因此我们认为造成这种情况是因为这不是三个独立的问题。我们认为，这是同一个问题的三个症状。问题在于 React 没有原生提供一个比 class 组件更简单、更小型、更轻量级的方式来添加 state 或生命周期。 而且一旦你使用了 class组件，你没有办法在不造成“包装地狱”的情况下,进一步拆分它。事实上，这并不是一个新问题。如果你已经使用了 React 几年，你也许还记得在 React 刚出来的时候，事实上已经包含了一个针对该问题的解决方案。嗯，这个解决方案就是 mixins。Mixins 能够让你在 class 之间复用方法，并且可以减少嵌套。 所以我们要在 React 里面重新把 mixins 添加回来吗？ （对 … 不…）对了，不，不，我们不会添加 mixins。我的意思是之前使用mixins 的代码并不是无法使用了。但是我们不再推荐在 React 里使用 mixins。如果你好奇我们这么做的原因，可以在 React Blog 里面查看我们之前写的一篇文章，题目是《 Mixins 是有害的 》。在文章中，我们从实验结果发现 mixins 带来的问题远比它解决的问题多。因此，我们不推荐大家使用 mixins。 我们有一个提案那么也许我们解决不了这个问题了，因为这是 React 组件模型固有的问题。也许我们不得不选择接受现实。（笑声） 或者也许有另外一种书写组件的方法可以避免这些问题。 这也就是今天我将要分享的内容。 但是在开始分享我们在 React 上做出的改动和新特性之前，我想先讲讲一年前我们建立的 RFC 流程，RFC 表示 request for comments，它意味着无论是我们还是其他人想要对 React 做出大量变化或者添加新特性时,都需要撰写一个提案，提案里面需要包含动机的详情和该提案如何工作的详细设计。 这正是我们要做的事情。我们非常兴奋地宣布：我们已经准备好了一个提案来解决这三个问题。 重要的是，本提案没有不向下兼容的变化，也没有弃用任何功能。本提案是严格添加性的、可选择的而且增加了一些新的 API 来帮助我们解决这些问题。并且我们希望听到你们对本提案的反馈，这也是为什么我们在今天发布本提案的原因。 我们想过很多发布本提案的方式，也许我们可以写好提案后，提出一个 RFC 然后放在那里。但是既然我们总是要召开 React 大会，我们决定在本次大会上发布这个提案。 Demo 环节那么，接下来进入 Demo 环节。（掌声） 我的屏幕已经投在了显示器上。对不起，有点技术故障。呃，有谁会用这个投影仪，来帮帮我。（笑声） 呃，我能复制我的桌面吗？请。（我能） 是啊。（笑声）好的，但是屏幕上没有显示，我什么都看不到。 （笑声）这就是我现在的问题。 （掌声）好的，灾难过去了。（笑声）好的，嗯，让我来稍微调整下文字大小。你们能看清吗？ （可以的。） 好的。 一个熟悉的 class 组件例子那么，我们来看，这里是一个普通的 React 组件，这是一个 Row 组件，这里有一些样式，然后渲染出一个人名。 123456789101112import React from &apos;react&apos;;import Row from &apos;./Row&apos;;export default function Greeting(props) { return ( &lt;section&gt; &lt;Row label=&quot;Name&quot;&gt; {props.name} &lt;/Row&gt; &lt;/section&gt; );} 我们想要做的是让这个名字可编辑。那么平时我们在 React 里通常是怎么做的呢？我们需要在这里添加一个 input，需要将这些内容放到class 里面返回，添加一些本地 state，让 state 来驱动 input。这也是我准备做的事情。这也是现今大家通常做的事情。 我要导出 default class Greeting 继承 React.Component。我在这里只会使用稳定的 JavaScript语法。接下来是 constructor(props), super (props)。在这里把 state 里的 name 初始化为 Mary。接下来我要声明一个 render 函数，复制一下这段代码然后粘贴到这里。对不起。好的。 我希望这里不再仅仅渲染 name，我希望这里可以渲染一个 input。我把这里替换为一个 input，然后 input 的值设置为 this.state.name。然后在 input 输入发生变化时，调用 this.handleNameChange，这是我的change 事件的回调函数。我把它声明在这里，当名字发生变化时，像我们通常做的那样调用 setState 方法。然后将 name 设置为 e.target.value。对吧。 如果我编辑 … （页面上报了 TypeError 的错误） 好吧，所以我应该去绑定 … （笑声） 对不起，我需要在这里绑定 event 事件。 好的，现在这样我们就可以编辑它了，运行正常。 这个 class 组件我们应该非常熟悉了。你如果使用 React 开发可能会遇到很多类似的代码。 12345678910111213141516171819202122232425262728293031import React from &apos;react&apos;;import Row from &apos;./Row&apos;;export default class Greeting extends React.Component { constructor(props) { super(props); this.state = { name: &apos;Mary&apos; } this.handleNameChange = this.handleNameChange.bind(this); } handleNameChange(e) { this.setState({ name: e.target.value }) } render() { return ( &lt;section&gt; &lt;Row label=&quot;Name&quot;&gt; &lt;input value={this.state.name} onChange={this.handleNameChange} /&gt; &lt;/Row&gt; &lt;/section&gt; ); }} 该功能可以用 function 组件实现吗但让我们后退一步，如果想要使用 state 时，能不能不必须使用 class 组件呢？我不确定该怎么做。但是我就准备跟据我的已知来进行，我需要渲染一个 input。我在这里放入一个 input。这个 input 的 value 的值为当前的 name 的值，所以我就传入 name 值。我不知道从哪里获取 name。它不是从 props 里面来，嗯，我就在这里声明，我不知道它的值，之后我再填写这一块。 呃，这里应该也有一个 change 回调函数，我在这里声明 onChange 函数 handleNameChange。我在这里添加一个函数来处理事件。在这里我想要通知 React 设置 name 值到某处，但又一次地，我不确定在 function 组件里如何实现这个功能。因此我就直接调用一个叫做 setName 的方法。使用当前的 input 的值。我把它声明在这里。 12345678910111213141516171819202122import React from &apos;react&apos;;import Row from &apos;./Row&apos;;export default function Greeting(props) { const name = ??? const setName = ??? function handleNameChange(e) { setName(e.target.value); } return ( &lt;section&gt; &lt;Row label=&quot;Name&quot;&gt; &lt;input value={name} onChange={handleNameChange} /&gt; &lt;/Row&gt; &lt;/section&gt; );} 好吧，由于这两件事情是密切相关的，对吧。其中一个是 state 里 name 变量的当前值，而另一个是一个函数，该函数让我们去设置 state 里的 name 变量。由于这两件事情非常相关，我将它们合并到一起作为一对值。 1234- const name = ???- const setName = ???+ const [name, setName] = ??? 我们从某处一同获取到它们的值。所以问题是我从哪里获取到它们？答案是从 React 本地状态里面获取。 那么我如何在 function 组件里面获取到 React 到本地状态呢？嗯，我直接使用 useState 会怎样。把初始到状态传给 useState 函数来指定它的初始值。 123456789101112131415161718192021import React, { useState } from &apos;react&apos;;import Row from &apos;./Row&apos;;export default function Greeting(props) { const [name, setName] = useState(&apos;Mary&apos;); function handleNameChange(e) { setName(e.target.value); } return ( &lt;section&gt; &lt;Row label=&quot;Name&quot;&gt; &lt;input value={name} onChange={handleNameChange} /&gt; &lt;/Row&gt; &lt;/section&gt; );} 我们来看一下程序运行是否正常。是的，运行正常。 （掌声和欢呼声） 那么我们来比较一下这两种方式。在左侧是我们熟悉的 class 组件。这里 state 必须是一个对象。嗯，我们绑定一些事件处理函数以便调用。在事件处理函数里面使用了 this.setState 方法。当我们调用 setState 方法时，实际上并没有直接将值设置到 state 里面，state 作为参数合并到 state 对象里。而当我想要获取 state 时，我们需要调用 this.state.something。 12345678910111213141516171819202122232425262728293031import React from &apos;react&apos;;import Row from &apos;./Row&apos;;export default class Greeting extends React.Component { constructor(props) { super(props); this.state = { name: &apos;Mary&apos; } this.handleNameChange = this.handleNameChange.bind(this); } handleNameChange(e) { this.setState({ name: e.target.value }) } render() { return ( &lt;section&gt; &lt;Row label=&quot;Name&quot;&gt; &lt;input value={this.state.name} onChange={this.handleNameChange} /&gt; &lt;/Row&gt; &lt;/section&gt; ); }} 那么我们再来看右侧的例子：我们不需要使用 this.state.something 来获取 state。因为 state 里的 name 变量在函数里已经可用。它就是一个变量。同样的，当我们需要设置 state 时，我们不需要使用 this.something。因为函数也可以让我们在其作用域内设置 name 的值。那么 useState 到底是什么呢？ useState 是一个 Hook。Hook 是一个 React 提供的函数，它可以让你在 function 组件中“钩”连 到一些 React 特性。而useState 是我们今天讲到的第一个 hook，后面还有一些更多的 hook。我们随后会看到它们。 123456789101112131415161718192021import React, { useState } from &apos;react&apos;;import Row from &apos;./Row&apos;;export default function Greeting(props) { const [name, setName] = useState(&apos;Mary&apos;); function handleNameChange(e) { setName(e.target.value); } return ( &lt;section&gt; &lt;Row label=&quot;Name&quot;&gt; &lt;input value={name} onChange={handleNameChange} /&gt; &lt;/Row&gt; &lt;/section&gt; );} 使用 class 和 hook 两种方式实现增加姓氏编辑区域好的，让我们回到我们熟悉的 class 例子。我们接下来想要添加第二个区域。比如，添加一个姓氏的区域。那么我们通常的做法是在 state 添加一个新 key。我把这行复制然后粘贴到这里。这里改成 surname。在这里渲染，这里是 surname 和 handleSurnameChange。我再来复制这个事件处理函数，把这里改成 surname。别忘了绑定这个函数。好的，Mary Poppins 显示出来了，我们可以看到程序运行正常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from &apos;react&apos;;import Row from &apos;./Row&apos;;export default class Greeting extends React.Component { constructor(props) { super(props); this.state = { name: &apos;Mary&apos;, surname: &apos;Poppins&apos;, } this.handleNameChange = this.handleNameChange.bind(this); this.handleSurnameChange = this.handleSurnameChange.bind(this); } handleNameChange(e) { this.setState({ name: e.target.value }) } handleSurnameChange(e) { this.setState({ surname: e.target.value }) } render() { return ( &lt;section&gt; &lt;Row label=&quot;Name&quot;&gt; &lt;input value={this.state.name} onChange={this.handleNameChange} /&gt; &lt;/Row&gt; &lt;Row label=&quot;Surname&quot;&gt; &lt;input value={this.state.surname} onChange={this.handleSurnameChange} /&gt; &lt;/Row&gt; &lt;/section&gt; ); }} 那么我们如何使用 hook 来实现相同的功能呢？我们需要做的一件事情是把我们的 state 改为一个对象。可以看到，使用 hook 的 state 并不强制其类型必须为对象。它可以是任何原生的 JavaScript 类型。我们可以在需要的时候把它变为对象，但是我们不用必须这么做。 从概念上讲，surname 和name 关系不大。所以我们需要做的是，再次调用 useState hook 来声明第二个 state 变量。在这里我声明 surname，当然我可以给它起任何名字，因为它就是我程序里的一个变量。再来设置 setSurname。调用 useState，传入 state 初始变量 ‘Poppins’。我再一次复制和粘贴这个 Row 片段。值改为 surname，onchange 事件改为 handleSurnameChange。当用户编辑surname 时，不是 sir name，我们希望能够修改 surname 的值。 1234567891011121314151617181920212223242526272829303132import React, { useState } from &apos;react&apos;;import Row from &apos;./Row&apos;;export default function Greeting(props) { const [name, setName] = useState(&apos;Mary&apos;); const [surname, setSurname] = useState(&apos;Poppins&apos;); function handleNameChange(e) { setName(e.target.value); } function handleSurameChange(e) { setSurname(e.target.value); } return ( &lt;section&gt; &lt;Row label=&quot;Name&quot;&gt; &lt;input value={name} onChange={handleNameChange} /&gt; &lt;/Row&gt; &lt;Row label=&quot;Surname&quot;&gt; &lt;input value={surname} onChange={handleSurnameChange} /&gt; &lt;/Row&gt; &lt;/section&gt; );} 我们来看看能否正常运行。耶，运行正常。 （掌声） 所以我们可以看到，我们可以在组件里使用多次 hook。 我们来更详细地比较这两种方式。在左侧我们熟悉的 class 组件里的 state 总是一个对象，具有多个字段，需要调用 setState 函数将其中的某些值合并进 state 对象中。当我们需要获取它时，需要调用 this.state.something。在右侧使用 hook 的例子中，我们使用了两次 hook，声明了两个变量：name 和 surname。而且每当我们调用 setName 或 setSurname 时，React 会接到需要重新渲染该组件的通知，就和调用 setState 一样。所以下一次 React 渲染组件会将当前的 name 和 surname 传递给组件。而且我们可以直接使用这些 state 变量，不需要调用 this.state.something。 用 class 和 hook 两种方式使用 React context好的。我们再回到我们的 class 组件的例子。有没我们知道的其他的 React 特性呢？那么另外一个你可能希望在组件里面做的事情就是读取 context。有可能你对 context 还不熟悉，它就像一种为了子树准备的全局变量。 Context 在需要获取当前主题或者当前用户正在使用的语言很有用。尤其是所有组件都需要读取一些相同变量时，使用 context 可以有效避免总是通过 props 传值。 让我们导入 ThemeContext 和 LocaleContext，这两个 context 我已经在另一个文件里定义好了。可能你们最熟悉的用来消费 context，尤其是消费多个 context 的 API 就是 render prop API。就像这样写。我往下滚动到这里。我们使用 ThemeContext Consumer 获得主题。在我的例子里，主题就是个简单的样式。我把这段代码复制，将其全部放入render prop 内部。将 className 赋值为 theme。好的，非常老旧的样式。（笑声） 我也想展示当前的语言，因此我将要使用 LocaleContext Consumer。我们再来渲染另一行，把这行代码复制粘贴到这里，改成 language。 Language。在这里渲染。好的，我们能够看到 context 运行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React from &apos;react&apos;;import Row from &apos;./Row&apos;;import { ThemeContext, LocaleContext } from &apos;./context&apos;;export default class Greeting extends React.Component { constructor(props) { super(props); this.state = { name: &apos;Mary&apos;, surname: &apos;Poppins&apos;, } this.handleNameChange = this.handleNameChange.bind(this); this.handleSurnameChange = this.handleSurnameChange.bind(this); } handleNameChange(e) { this.setState({ name: e.target.value }) } handleSurnameChange(e) { this.setState({ surname: e.target.value }) } render() { return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; ( &lt;section className={theme}&gt; &lt;Row label=&quot;Name&quot;&gt; &lt;input value={this.state.name} onChange={this.handleNameChange} /&gt; &lt;/Row&gt; &lt;Row label=&quot;Surname&quot;&gt; &lt;input value={this.state.surname} onChange={this.handleSurnameChange} /&gt; &lt;/Row&gt; &lt;LocaleContext.Consumer&gt; {locale =&gt; ( &lt;Row label=&quot;Language&quot;&gt; {locale} &lt;/Row&gt; )} &lt;/LocaleContext.Consumer&gt; &lt;/section&gt; )} &lt;/ThemeContext.Consumer&gt; ); }} 这也许是最普通的消费 context 情况了。实际上，我们在 React 16.6 版本上增加了一个更加方便的 API 来获取它。呃，但是这就是你们常见的多 context 的情形。那么我们看一下如何使用 hook 实现相同的功能。 就像我们所说，state 是 React 的基础特性，因此我们可以使用 useState 来获取 state。那么如果我们想要使用 context，首先需要导入我的 context。这里导入 ThemeContext 和 LocaleContext。现在如果我想在我组件里使用 context，我可以使用 useContext。可以使用 ThemeContext 获取当前的主题，使用 LocaleContext 获取当前的语言。这里 useContext 不只是读取了 context，它也订阅了该组件，当 context 发生变化，组件随之更新。但现在 useContext 就给出了 ThemeContext 的当前值 theme，所以我可以将其赋给 className。接下来我们添加一个兄弟节点，把label 改为 Language， 把 locale 放到这里。 （掌声） 123456789101112131415161718192021222324252627282930313233343536373839import React, { useState, useContext } from &apos;react&apos;;import Row from &apos;./Row&apos;;import { ThemeContext, LocaleContext } from &apos;./context&apos;;export default function Greeting(props) { const [name, setName] = useState(&apos;Mary&apos;); const [surname, setSurname] = useState(&apos;Poppins&apos;); const theme = useContext(ThemeContext); const locale = useContext(LocaleContext); function handleNameChange(e) { setName(e.target.value); } function handleSurameChange(e) { setSurname(e.target.value); } return ( &lt;section className={theme}&gt; &lt;Row label=&quot;Name&quot;&gt; &lt;input value={name} onChange={handleNameChange} /&gt; &lt;/Row&gt; &lt;Row label=&quot;Surname&quot;&gt; &lt;input value={surname} onChange={handleSurnameChange} /&gt; &lt;/Row&gt; &lt;Row label=&quot;Language&quot;&gt; {locale} &lt;/Row&gt; &lt;/section&gt; );} 那么，让我们比较这两个方法。左边的例子是传统的 render prop API 的使用方式。非常清楚地显示了它正在做什么。但是它还包含了一点点的嵌套，而且嵌套问题不只会在使用 context 的情况下出现，使用任何一种类型的render prop API 都会遇到。 我们使用 hook 也能实现相同的功能。但是代码会更扁平。那么我们来看一下，我们使用了两个 useContext，从中我们得到了 theme 和 locale。然后我们可以使用它们了。你可能想问 React 是如何知道的，例如，我在这调用了两个 useState,那么 React 是如何知道哪一个 state 和调用的哪一个 useState 是相对应的呢？答案是 React 依赖于这些调用的顺序，这可能有一点不太寻常。 为了让 hook 正确地运行，在使用 hook 时，我们需要遵循一条规则：不能在条件判断里面调用 hook，它必须在你的组件的顶层。举个例子，我做一些类似于 if props 条件的判断，然后我在条件里面调用 useState hook。我们开发了一个 Linter 插件，此时会提示 ‘This is not the correct way to use hooks’。 虽然这是一个不同寻常的限制，但是这对 hook 正常运行十分重要，同时可以使事情变得更明确，我认为你们会喜欢它的，我等会儿会向你们展示它。 如何使用 class 和 hook 两种方式处理副作用那么，让我们回头看看我们的 class。你使用 class 想要做到的另一件事可能就是生命周期函数。而最普遍的使用生命周期函数的案例就是处理一些副作用，比如发送请求，或者是调用某些浏览器 API 来监测 DOM 变化。但是你不能在渲染阶段去做这些类似的事情，因为此时 DOM 可能还没有渲染完成。因此，在 React 中处理副作用的方法是声明如 componentDidMount 的生命周期方法。 那么比如说，嗯，让我向你们展示一下这个。那么，你看到在屏幕的顶部，页签上显示的标题是 React App。这里实际上有一个让我们更新这个标题的浏览器 API。现在我们想要这个页签的标题变成这个人的名字，并且能够随着我输入的值而改变。 现在我要初始化它。嗯，有一个浏览器 API 可以做这件事，那就是 document.title，等于this.state.name 加空格加 this.state.surname。现在我们可以看见这里显示出了 Mary Poppins。但是如果我编辑姓名，页签上的标题没有自动地更新，因为我还没有实现 componentDitUpdate 方法。为了让该副作用和我渲染保持一致，我在这里声明 componentDitUpdate,然后复制这段代码并粘贴到这里。现在标题显示的是 Mary Poppins，如果我开始编辑输入框，页签标题也随之更新了。这就是我们如何在一个 class 里处理副作用的例子。 12345678+ componentDidMount() {+ document.title = this.state.name + ' ' + this.state.surname;+ }+ componentDidUpdate() {+ document.title = this.state.name + ' ' + this.state.surname;+ } 那么我们要如何用 hook 实现相同的功能呢？处理副作用的能力是 React 组件的另一个核心特性。所以如果我们想要使用副作用，我们需要从 React 里导入一个 useEffect。然后我们要告诉 React 在 React 清除组件之后对 DOM 做什么。所以我们在 useEffect里面传递一个函数作为参数，在函数里处理副作用，在这里代码改为 document.title = name + ' ' + surname。 123456- import React, { useState, useContext } from 'react';+ import React, { useState, useContext, useEffect } from 'react';+ useEffect(() =&gt; {+ document.title = name + ' ' + surname;+ }) 可以看到，页面标题显示为 Mary Poppins。如果我开始编辑它，页面标题也会随之更新。 所以，userEffect 默认会在初始渲染和每一次更新之后执行。所以通过默认的，页面标题与这里渲染的内容保持一致。如果出于性能考虑或者有特殊的逻辑，可以选择不采用这种默认行为。在我之后，Ryan 的演讲将会涉及到一些关于这个方面的内容。 那么让我们来比较这两个方法。在左边这个class 里，我们将逻辑分开到不同名称的生命周期方法中。这也是我们为什么会有 componentDidMount 和 componentDitUpdate 的原因，它们在不同的时间上被触发。我们有时候会在它们之间重复一些逻辑。虽然可以把这些逻辑放进一个函数里，但是我们仍然不得不在两个地方调用它，而且要记得保持一致。 而使用 effect hook，默认具有一致性，而且可以选择不使用该默认行为。需要注意的是，在 class 中我们需要访问 this.state， 所以需要一个特殊的 API 来实现。但是在这个 effect 例子中，实际上不需要一个特殊的 API 去访问这个 state 变量。因为它已经在这个函数的作用域里，在上文中已经声明。这就是 effect 被声明在组件内部的原因。而且这样我们也可以访问 state 变量和 context，并且可以为它们赋值。 订阅的两种实现那么，让我们回头看看熟悉的 class 的例子。嗯，其他你可能需要在 class 里使用生命周期方法实现的就是订阅功能。你可能想要去订阅一些浏览器 API，它会提供给你一些值，例如窗口的大小。你需要组件随着这个 state 值的改变更新。那么我们在 class 里实现这个功能的方法是，比如说我们想要，嗯，我们想要监测窗口的宽度。 我将 width 放进 state 里。使用 window.innerWidth 浏览器 API 来初始化。然后我想要渲染它。嗯，让我们复制并且粘贴这段代码。这里改为 width。我将在这个地方渲染它。这里改为 this.state.width。这就是窗口的宽度了，而不是 Mary Poppins 的宽度。（大笑）我将添加一个，嗯，我将要添加一个事件监听，所以我们需要真真切切地监听这个 width 的改变。所以设置 window.addEventListener。我将监听 resize 事件， handleResize。然后我需要声明这个事件。在这里我们更新这个 width 状态，设置为 window.innerWidth。然后我们需要去绑定它。 然后，嗯，然后我也需要取消订阅。所以我不想因为保留这些订阅造成内存泄漏。我想要取消这个事件的订阅。我们在一个 class 里处理的方式是创建另一个叫做 componentWillUnmount 的生命周期方法。然后我将这段逻辑代码复制并且粘贴到这里，将这里改为 removeEventListener。我们设置了一个事件监听，并且我们移除了这个事件监听。我们可以通过拖动窗口来验证。你看到这个 width 正在变化。运行正常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import React from 'react';import Row from './Row';import { ThemeContext, LocaleContext } from './context';export default class Greeting extends React.Component { constructor(props) { super(props); this.state = { name: 'Mary', surname: 'Poppins',+ width: window.innerWidth, } this.handleNameChange = this.handleNameChange.bind(this); this.handleSurnameChange = this.handleSurnameChange.bind(this);+ this.handleResize = this.handleResize.bind(this); } componentDidMount() { document.title = this.state.name + ' ' + this.state.surname;+ window.addEventListener('resize', handleResize); } componentDidUpdate() { document.title = this.state.name + ' ' + this.state.surname; }+ componentWillUnmount() {+ window.removeEventListener('resize', handleResize);+ }+ handleResize() {+ this.setState({+ width: window.innerWidth+ });+ } handleNameChange(e) { this.setState({ name: e.target.value }) } handleSurnameChange(e) { this.setState({ surname: e.target.value }) } render() { return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; ( &lt;section className={theme}&gt; &lt;Row label=\"Name\"&gt; &lt;input value={this.state.name} onChange={this.handleNameChange} /&gt; &lt;/Row&gt; &lt;Row label=\"Surname\"&gt; &lt;input value={this.state.surname} onChange={this.handleSurnameChange} /&gt; &lt;/Row&gt; &lt;LocaleContext.Consumer&gt; {locale =&gt; ( &lt;Row label=\"Language\"&gt; {locale} &lt;/Row&gt; )} &lt;/LocaleContext.Consumer&gt;+ &lt;Row label=\"Width\"&gt;+ {this.state.width}+ &lt;/Row&gt; &lt;/section&gt; )} &lt;/ThemeContext.Consumer&gt; ); }} 那么让我们看看如何可以，我们如何用 hook 实现这个功能。从概念上来说，监听窗口宽度与设置文档标题无关。这就是为什么我们没有把它放入这个 useEffect 里的原因。它们在概念上是完全独立的副作用，就像我们可以使用多次的 useState 用来声明多个 state 变量，我们可以使用多次 useEffect 来处理不同的副作用。 这里我想要订阅 window.addEventListener ，resize，handleResize。然后我需要保存当前 width 的状态。所以，我将声明另一组 state 变量。所以这里声明 width 和 setWidth。我们通过 useState 设置他们的初始值为 window.innerWidth。现在我把 handleResize 函数声明在这里。因为它没有在其他地方被调用。然后用 setWidth 来设置当前的 width。嗯，我需要去渲染它。所以我复制并粘贴这个 Row。这里改为 width。 最后我需要在这个 effect 之后去清除它。所以我需要指定如何清除。从概念上说，清除也是这个 effect 的一部分。所以这个 effect 有一个清除的地方。这个顺序，你可以指定如何清除订阅的方法是，effect 可以选择返回一个函数。如果它返回一个函数，那么 React 将在 effect 之后调用这个函数进行清除操作。所以这就是我们取消订阅的地方。好的，让我们验证一下它能否正常运行吧。耶！（掌声） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, { useState, useContext, useEffect } from 'react';import Row from './Row';import { ThemeContext, LocaleContext } from './context';export default function Greeting(props) { const [name, setName] = useState('Mary'); const [surname, setSurname] = useState('Poppins'); const theme = useContext(ThemeContext); const locale = useContext(LocaleContext); useEffect(() =&gt; { document.title = name + ' ' + surname; })+ const [width, setWidth] = useState(window.innerWidth);+ useEffect(() =&gt; {+ const handleResize = () =&gt; setWidth(window.innerWidth);+ window.addEventListener('resize', handleResize);+ return () =&gt; {+ window.removeEventListener('resize', handleResize);+ };+ }) function handleNameChange(e) { setName(e.target.value); } function handleSurameChange(e) { setSurname(e.target.value); } return ( &lt;section className={theme}&gt; &lt;Row label=\"Name\"&gt; &lt;input value={name} onChange={handleNameChange} /&gt; &lt;/Row&gt; &lt;Row label=\"Surname\"&gt; &lt;input value={surname} onChange={handleSurnameChange} /&gt; &lt;/Row&gt; &lt;Row label=\"Language\"&gt; {locale} &lt;/Row&gt;+ &lt;Row label=\"Width\"&gt;+ {width}+ &lt;/Row&gt; &lt;/section&gt; );} 那么让我们比较这两个方法。在左边，我们使用了一个熟悉的 class 组件，嗯，在这没有令人惊喜的东西。我们有一些副作用，一些相关的逻辑是分开的：我们可以看到文档的标题在这里被设置，但是它在这也被设置了。并且我们在这订阅 effect，抱歉，在这订阅这个事件，但是我们在这里取消订阅。所以这些事情需要相互保持同步。而且这个方法包含了两个不相关的方法，在这不相关的两行。因此，我在未来有点难以单独测试它们。但是它看起来非常熟悉，这点也不错。 那么这段代码看起来可能会就不那么熟悉了。但让我们来看一看这里发生了什么。嗯，在 hook 中，我们分离代码不是基于生命周期函数的名字，而是基于这段代码要做什么。所以我们可以看到这个有一个 effect，我们用来更新文档的标题这是一件这个组件能做的事。这里有另一个 effect，它订阅了 window 的 resize 事件，并且当 window 的大小发生改变时，state 随之更新。然后，嗯，这个 effect 有一个清除阶段，它的作用是移除这个 effect 时，React 取消事件监听从而避免内存泄漏。如果你一直仔细观察，你可能注意到由于 effect 在每次渲染之后运行，我们会重新订阅。有一个方法可以优化这个问题。默认是一致的，这很重要。如果你，例如在这使用一些 prop，我需要去重新订阅一个不同的 id ，该 id 来自 props 或类似的地方。但是这儿有一个方法去优化它，并且可以选择不用这个行为。Ryan 在下一个演讲中将会提到如何去实现它。 Custom Hook好的，我在这里还想要演示另外一件事。现在组件已经非常庞大了，这也没有太大的问题。我们考虑到在 function 组件中你们有可能做更多的事情，组件会变得更大，但也完全没有问题。嗯，但是你有可能想要复用其他组件里面到一些逻辑，或者是想要将公用的逻辑抽取出来，或者是想要分别测试。有趣的是， hook 调用实际上就是函数调用。而且组件就是函数。那么我们平时是如何在两个函数之间共享逻辑呢。我们会将公用逻辑提取到另外一个函数里面。这也是我将要做的事情。我把这段代码复制粘贴到这里。我要新建一个叫做 useWindowWidth 的函数。然后把它粘贴到这里。我们需要组件里面的宽度，以便能够将其渲染。因为我需要在这个函数里面返回当前宽度。然后我们回到上面的代码，这样修改： const width = useWindowWidth。 （掌声和欢呼声） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React, { useState, useContext, useEffect } from 'react';import Row from './Row';import { ThemeContext, LocaleContext } from './context';export default function Greeting(props) { const [name, setName] = useState('Mary'); const [surname, setSurname] = useState('Poppins'); const theme = useContext(ThemeContext); const locale = useContext(LocaleContext);+ const width = useWindowWidth(); useEffect(() =&gt; { document.title = name + ' ' + surname; })- const [width, setWidth] = useState(window.innerWidth);- useEffect(() =&gt; {- const handleResize = () =&gt; setWidth(window.innerWidth);- window.addEventListener('resize', handleResize);- return () =&gt; {- window.removeEventListener('resize', handleResize);- };- }) function handleNameChange(e) { setName(e.target.value); } function handleSurameChange(e) { setSurname(e.target.value); } return ( &lt;section className={theme}&gt; &lt;Row label=\"Name\"&gt; &lt;input value={name} onChange={handleNameChange} /&gt; &lt;/Row&gt; &lt;Row label=\"Surname\"&gt; &lt;input value={surname} onChange={handleSurnameChange} /&gt; &lt;/Row&gt; &lt;Row label=\"Language\"&gt; {locale} &lt;/Row&gt; &lt;Row label=\"Width\"&gt; {width} &lt;/Row&gt; &lt;/section&gt; );}+function useWindowWidth() {+ const [width, setWidth] = useState(window.innerWidth);+ useEffect(() =&gt; {+ const handleResize = () =&gt; setWidth(window.innerWidth);+ window.addEventListener('resize', handleResize);+ return () =&gt; {+ window.removeEventListener('resize', handleResize);+ };+ })+ return width;+} 那么这个函数是什么呢？我们并没有做什么特别的事情，我们仅仅是将逻辑提取到了一个函数里面。呃，但是这里有一个约定。我们把这种函数叫做 custom hook。按照约定，custom hook 的名字需要以 use 开头。这么约定主要有两个原因。 我们会读你的函数名或修改函数名称。但是这是一个重要的约定，因为首先以 use 开头来命名 custom hook，可以让我们自动检测是否违反了我之前说过的第一条规则：不能在条件判断里面使用 hook。因此如果我们无法得知哪些函数是 hook，那么我们就无法做到自动检测。 另一个原因是，如果你查看组件的代码，你可能会想要知道某个函数里面是否含有 state。因此这样的约定很重要，好的，以 use 开头的函数表示这个函数是有状态的。 在这里 width 变量给了我们当前的宽度并且订阅了其更新。如果我们想，我们可以更进一步。在这个例子里面也许并不必要，但是我想要给你一个思路。嗯，我们也许设置文档的标题的功能会更加复杂，你希望能够把它的逻辑提取出来并单独测试。那么我把这段代码复制过来粘贴到这里。我可以写一个新的 custom hook。我把这个 hook 命名为useDocumentTitle。由于name 和 surname 在上下文作用域里没有意义。我希望调用标题，标题就是一个参数，由于 custom hook 就是 JavaScript 函数，因此他们可以传递参数，返回值或者不返回。这里我把 title 设置为参数。然后在组件里面，使用 useDocumentTitle，参数为 name 加上 surname。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, { useState, useContext, useEffect } from 'react';import Row from './Row';import { ThemeContext, LocaleContext } from './context';export default function Greeting(props) { const [name, setName] = useState('Mary'); const [surname, setSurname] = useState('Poppins'); const theme = useContext(ThemeContext); const locale = useContext(LocaleContext); const width = useWindowWidth();+ useDocumentTitle(name + ' ' + surname);- useEffect(() =&gt; {- document.title = name + ' ' + surname;- }) function handleNameChange(e) { setName(e.target.value); } function handleSurameChange(e) { setSurname(e.target.value); } return ( &lt;section className={theme}&gt; &lt;Row label=\"Name\"&gt; &lt;input value={name} onChange={handleNameChange} /&gt; &lt;/Row&gt; &lt;Row label=\"Surname\"&gt; &lt;input value={surname} onChange={handleSurnameChange} /&gt; &lt;/Row&gt; &lt;Row label=\"Language\"&gt; {locale} &lt;/Row&gt; &lt;Row label=\"Width\"&gt; {width} &lt;/Row&gt; &lt;/section&gt; );}+function useDocumentTitle(title) {+ useEffect(() =&gt; {+ document.title = title;+ })+}function useWindowWidth() { const [width, setWidth] = useState(window.innerWidth); useEffect(() =&gt; { const handleResize = () =&gt; setWidth(window.innerWidth); window.addEventListener('resize', handleResize); return () =&gt; { window.removeEventListener('resize', handleResize); }; }) return width;} 事实上，我可以更进一步。在这个例子中是完全没有必要的，但是同样的道理，也许我们的输入框会更加的复杂，也许我们需要追踪输入框的聚焦或失焦事件，或者输入框是否被校验过、提交过等等。也许我们还有更多的逻辑想要从组件中抽离。嗯，而且想要减少重复代码。这里已经有了重复的代码，这两段事件处理函数几乎一样。 那么我们如果，呃，我把他们删除一段，然后提取另一段。我要创建另一个新 hook，把它命名为 useFormInput。这个 hook 是我的 change 处理函数。现在我把这个声明复制粘贴到这里。这里定义了输入框的状态。这里不再是 name 和 setName。我把这里改为更通用的 value 和 setValue。我把初始值作为参数。这里改为 handleChange，这里改为 setValue。那么我们该如何做在我们组件里面使用输入框呢？我们需要获取当前的 value 和 change 处理函数。这是我们需要赋给输入框的。所以我们就在 hook 里面返回他们。嗯，返回 value 和 onChange handleChange 函数。我们回到组件里面，这里改为 name 等于 useFormInput，参数 Mary。这里 name 变为了一个对象，包括 value 和 onChange 函数。这里 surname 等于 useFormInput，初始化参数 Poppins。这里改为 name.value 和 surname.value。因为这两个值才是我们需要的字符串。接下来我把这里删除，然后将其改为 spread 属性。有人在笑。[笑声] 好的。我们来验证一下，是的，运行正常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React, { useState, useContext, useEffect } from 'react';import Row from './Row';import { ThemeContext, LocaleContext } from './context';export default function Greeting(props) {- const [name, setName] = useState('Mary');- const [surname, setSurname] = useState('Poppins');+ const name = useFormInput('Mary');+ const surname = useFormInput('Poppins'); const theme = useContext(ThemeContext); const locale = useContext(LocaleContext); const width = useWindowWidth();- useDocumentTitle(name+ ' ' + surname);+ useDocumentTitle(name.value + ' ' + surname.value);- function handleNameChange(e) {- setName(e.target.value);- }- function handleSurameChange(e) {- setSurname(e.target.value);- } return ( &lt;section className={theme}&gt; &lt;Row label=\"Name\"&gt;- &lt;input- value={name}- onChange={handleNameChange}- /&gt;+ &lt;input {...name} /&gt; &lt;/Row&gt; &lt;Row label=\"Surname\"&gt;- &lt;input- value={surname}- onChange={handleSurnameChange}- /&gt;+ &lt;input {...surname} /&gt; &lt;/Row&gt; &lt;Row label=\"Language\"&gt; {locale} &lt;/Row&gt; &lt;Row label=\"Width\"&gt; {width} &lt;/Row&gt; &lt;/section&gt; );}+function useFormInput(initialValue) {+ const [value, setValue] = useState(initialValue);+ function handleChange(e) {+ setValue(e.target.value);+ }+ return {+ value,+ onChange: handleChange+ };+}function useDocumentTitle(title) { useEffect(() =&gt; { document.title = title; })}function useWindowWidth() { const [width, setWidth] = useState(window.innerWidth); useEffect(() =&gt; { const handleResize = () =&gt; setWidth(window.innerWidth); window.addEventListener('resize', handleResize); return () =&gt; { window.removeEventListener('resize', handleResize); }; }) return width;} 每次我们调用 hook，其状态都是完全独立的。这是因为我们依赖调用 hook 的顺序，而不是通过名称或其他方式来实现的。所以你可以多次调用相同的 hook。每次调用都会获取其自身的本地状态。 我们最后一次来比较这两种方式。嗯，在左侧我们熟悉的class 组件例子里，在一个对象里面有一些 state，绑定了一些方法，有一些逻辑分散到不同的声明周期方法里面，这些逻辑是一串事件处理函数。嗯，我们用了来自 context 的内容来渲染内容。嗯，这种情况我们相当熟悉了。 在右侧窗格里面，和我们常见的 React 组件不同。但是它是有意义的。即使你并不知道这些函数是如何实现的。你可以看到，这个函数就是用来组织输入框的，这个函数用了 context 来获取主题和本地语言，这个函数使用了窗口宽度和文档标题，然后渲染了一连串的内容。如果我们想了解更多，我们可以滚动窗口到下面，可以看到，这就是输入框如何运行的代码，这里是如何设置文档标题的代码，而这里是如何设置并订阅窗口宽度的代码。或许这里是一个 npm 包，实际上你没有必要了解它是如何实现的。我们可以将它在组件里面调用，或者在组件之间复制粘贴它们。 Hook 提供了 custom hook，为用户提供了灵活的创建自己的抽象函数的功能，custom hook 不会让你的 React 组建树变得庞大，而且可以避免“包装地狱”。 （掌声） 而且重要的是，这两个例子并不是独立的两个应用。实际上，这两个例子是在同一个应用里面。我把这个窗口打开的目的就是想要展示 class 可以和 hook 并肩工作。而 hook 代表这我们对 React 未来的期许，嗯，但是我们并不想做出不向下兼容的改变。我们还需要保证 class 可以正常运行。 Hook 提案我们回到幻灯片上来。好的，这张幻灯片就是你们可以发 tweet 的片子。 （笑声） 今天我们向你们展示了 Hook 提案。Hook 让我们可以在不使用 class 的情况下使用 React 的众多特性。而且我们没有弃用 class，但是我们给你们提供了一个不去写 class 的新选择。我们打算尽快完成使用 hook 来替代 class 的全部用例。目前还有一部分缺失，但是我们正在处理这部分内容。而且 hook 能够让大家复用有状态的逻辑，并将其从组件中提取出来，分别测试，在不同组件之间复用，并且可以避免引入“包装地狱”。 重要的是，hook 不是一个破坏性的改动，完全向后兼容，是严格添加性的。你可以从这个 url 查找到我们关于 hook 的文档。嗯，我们希望听到你们的反馈，React 社区希望了解到你们对 hook 的想法，嗯，无论你们喜欢与否。而且我们发现如果不让大家实际使用 hook，就会很难收到反意见。所以我们将 hook 构建发布到了 React 16.7 alpha 版本上。这个不是一个主要版本，是一个小版本。但是在这个 alpha 版本，你可以尝试使用 hook。而且我们在 Facebook 的生产环境已经测试了一个月，因此我们认为不会有大的缺陷。但是 hook 的 API 可以根据你们的反馈意见进行调整。而且我不建议你们把整个应用使用 hook 来重写。因为首先，hook 目前还在提案阶段。第二个原因，我个人认为，使用 hook 的思维方式需要一个思想上的改变，也许刚开始你们尝试把 class 组件转为 hook 写法会比较困惑。但是我推荐大家尝试在新的代码里使用 hook，并且让我们知道你们是怎么想的。那么，谢谢大家。 （掌声） 在我们看来，hook 代表着 React 的未来。但我认为这也代表着我们推进 React 发展的方式。那就是我们不进行大的重写。嗯，我们希望我们更喜欢的新模式可以和旧模式并存，这样我们就可以进行渐进迁移并接受这些新模式，就像你们逐渐接受 React 本身一样。 Hook 一直就在那里这也差不多是我演讲的结尾了。但是最后，我想讲讲一些我个人的观点。我从四年前学习 React。我遇到的第一个问题就是为什么要使用 JSX。 嗯，我第二个问题是 React 的 Logo 到底有什么含义。React 项目没有起名叫“原子”（Atom），它并不是一个物理引擎。嗯，有一个解释是，React 是基于反应的（reactions），原子也参与了化学反应（chemical reactions），因此 React 的 Logo 用了原子的形象。 但是 React 没有官方承认过这种说法。嗯，我发现了一个对我来说更有意义的解释。我是这样思考的，我们知道物质是由原子组成的。我们学过物质的外观和行为是由原和其内部的属性决定的。而 React 在我看来是类似的，你可以使用 React 来构建用户界面，将其拆分为叫做组件的独立单元。用户界面的外观和行为是由这些组件及其内部的属性决定的。 具有讽刺意味的是，“原子”（Atom）一词，字面上的意思是不可分割的。当科学家们首次发现原子的时候，他们认为原子是我们发现的最小的物质。但是之后他们就发现了电子，电子是原子内部更小的微粒。后来证明实际上电子更能描述原子运行的原理。 我对 hook 也有类似的感觉。我感觉 hook 不是一个新特性。我感觉 hook 提供了使用我们已知的 React 特性的能力，如 state 、context 和生命周期。而且我感觉 hook 就像 React 的一个更直观的表现。Hook 在组件内部真正解释了组件是如何工作的。我感觉 hook 一直在我们的视线里面隐藏了四年。事实上，如果看看 React 的 Logo，可以看到电子的轨道，而 hook 好像一直就在那里。谢谢。（掌声） 传送门 最重要的 React 官方文档：Introducing Hooks [译] React 的今天和明天（图文版） —— 第一部分 中英文字幕视频地址（B站）：【React Conf 2018】React 的今天和明天中英文双字幕 第一部分视频地址（爱奇艺）：React Today And Tomorrow Part I —— Sophie’s Keynote 中英双语字幕 第二部分视频地址（爱奇艺）：React Today And Tomorrow Part II —— Dan’s Keynote 中英双语字幕 Dan 对本次演讲的精炼文章（需要科学上网）：Making Sense of React Hooks 上面文章的译文：[译] 理解 React Hooks 一篇非常好的理解 React Hook 的文章：30 分钟精通 React Hooks 如果发现译文和字幕存在错误或其他需要改进的地方，欢迎到本项目的 GitHub 仓库 对英文字幕或译文进行修改并 PR，谢谢大家。当然后本视频还有后面 Ryan 给我带来的第三段题目为90% Cleaner React with Hooks 的演讲，欢迎有兴趣的小伙伴一起参与英文字幕校对和翻译工作。","link":"/2018/11/28/React_today_and_tomorrow2/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"React Hooks","slug":"React-Hooks","link":"/tags/React-Hooks/"},{"name":"React Conf 2018","slug":"React-Conf-2018","link":"/tags/React-Conf-2018/"},{"name":"Translation","slug":"Translation","link":"/tags/Translation/"},{"name":"Create React App","slug":"Create-React-App","link":"/tags/Create-React-App/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Ant Design","slug":"Ant-Design","link":"/tags/Ant-Design/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"Less","slug":"Less","link":"/tags/Less/"},{"name":"Dva","slug":"Dva","link":"/tags/Dva/"},{"name":"Umi","slug":"Umi","link":"/tags/Umi/"},{"name":"Design","slug":"Design","link":"/tags/Design/"},{"name":"UX","slug":"UX","link":"/tags/UX/"}],"categories":[{"name":"Front-End","slug":"Front-End","link":"/categories/Front-End/"},{"name":"Tools","slug":"Front-End/Tools","link":"/categories/Front-End/Tools/"},{"name":"JavaScript","slug":"Front-End/JavaScript","link":"/categories/Front-End/JavaScript/"},{"name":"React","slug":"Front-End/React","link":"/categories/Front-End/React/"},{"name":"Designs & Arts","slug":"Designs-Arts","link":"/categories/Designs-Arts/"},{"name":"UX","slug":"Designs-Arts/UX","link":"/categories/Designs-Arts/UX/"}]}